/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni 
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#ifndef TINYOPT_AST_H
#define TINYOPT_AST_H

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef enum
{
  NODE_PROGRAM,
  NODE_DECLARATION,
  NODE_ASSIGNMENT,
  NODE_EXPRESSION,
  NODE_CONDITION,
  NODE_IF_STATEMENT,
  NODE_WHILE_STATEMENT,
  NODE_FOR_STATEMENT,
  NODE_COMPOUND_STATEMENT,
  NODE_RETURN,
  NODE_BREAK,
  NODE_CONTINUE,
  NODE_IDENTIFIER,
  NODE_NUMBER,
  NODE_CHAR_LITERAL,
  NODE_STRING_LITERAL,
  NODE_BINARY_OP,
  NODE_UNARY_OP,
  NODE_FUNCTION_DEF,
  NODE_FUNCTION_CALL,
  NODE_PARAMETER_LIST
} NodeType;

typedef enum
{
  TYPE_INT,
  TYPE_FLOAT,
  TYPE_CHAR,
  TYPE_VOID,
  TYPE_ARRAY
} DataType;

typedef enum
{
  OP_ADD,
  OP_SUB,
  OP_MUL,
  OP_DIV,
  OP_MOD,
  OP_EQ,
  OP_NE,
  OP_LT,
  OP_LE,
  OP_GT,
  OP_GE,
  OP_AND,
  OP_OR,
  OP_NOT,
  OP_ASSIGN,
  OP_ADD_ASSIGN,
  OP_SUB_ASSIGN,
  OP_MUL_ASSIGN,
  OP_DIV_ASSIGN,
  OP_MOD_ASSIGN,
  OP_INC,
  OP_DEC
} Operator;

typedef struct ast_node TinyOptASTNode_t;

struct ast_node
{
  NodeType type;
  struct ast_node *next;
  struct ast_node *parent;
  int is_dead_code;
};

typedef struct program_node TinyOptProgramNode_t;

struct program_node
{
  TinyOptASTNode_t base;
  struct ast_node *statements;
};

typedef struct declaration_node TinyOptDeclarationNode_t;

struct declaration_node
{
  TinyOptASTNode_t base;
  DataType data_type;
  char *name;
  uint64_t hash;
  struct ast_node *initial_value;
  int array_size;
};

typedef struct assignment_node TinyOptAssignmentNode_t;

struct assignment_node
{
  TinyOptASTNode_t base;
  char *variable;
  uint64_t hash;
  Operator op;
  struct ast_node *value;
};

typedef struct expression_node TinyOptExpressionNode_t;

struct expression_node
{
  TinyOptASTNode_t base;
  Operator op;
  struct ast_node *left;
  struct ast_node *right;
  char *value;
};

typedef struct condition_node TinyOptConditionNode_t;

struct condition_node
{
  TinyOptASTNode_t base;
  Operator op;
  struct ast_node *left;
  struct ast_node *right;
};

typedef struct if_node TinyOptIfNode_t;

struct if_node
{
  TinyOptASTNode_t base;
  struct ast_node *condition;
  struct ast_node *then_statement;
  struct ast_node *else_statement;
};

typedef struct while_node TinyOptWhileNode_t;

struct while_node
{
  TinyOptASTNode_t base;
  struct ast_node *condition;
  struct ast_node *body;
  uint64_t loop_hash;
};

typedef struct for_node TinyOptForNode_t;

struct for_node
{
  TinyOptASTNode_t base;
  struct ast_node *init;
  struct ast_node *condition;
  struct ast_node *increment;
  struct ast_node *body;
  uint64_t loop_hash;
};

typedef struct compound_node TinyOptCompoundNode_t;

struct compound_node
{
  TinyOptASTNode_t base;
  struct ast_node *statements;
};

typedef struct return_node TinyOptReturnNode_t;

struct return_node
{
  TinyOptASTNode_t base;
  struct ast_node *value;
};

typedef struct control_node TinyOptControlNode_t;

struct control_node
{
  TinyOptASTNode_t base;
  int is_break;
};

typedef struct identifier_node TinyOptIdentifierNode_t;

struct identifier_node
{
  TinyOptASTNode_t base;
  char *name;
  uint64_t hash;
};

typedef struct number_node TinyOptNumberNode_t;

struct number_node
{
  TinyOptASTNode_t base;
  char *value;
  DataType data_type;
};

typedef struct charLiteral_node TinyOptCharLiteralNode_t;

struct charLiteral_node
{
  TinyOptASTNode_t base;
  char *value;
};

typedef struct string_literal_node TinyOptStringLiteralNode_t;

struct string_literal_node
{
  TinyOptASTNode_t base;
  char *value;
};

typedef struct binary_op_node TinyOptBinaryOpNode_t;

struct binary_op_node
{
  TinyOptASTNode_t base;
  Operator op;
  struct ast_node *left;
  struct ast_node *right;
};

typedef struct unary_op_node TinyOptUnaryOpNode_t;

struct unary_op_node
{
  TinyOptASTNode_t base;
  Operator op;
  struct ast_node *operand;
};

typedef struct function_def_node TinyOptFunctionDefNode_t;

struct function_def_node
{
  TinyOptASTNode_t base;
  DataType return_type;
  char *name;
  struct ast_node *parameters;
  struct ast_node *body;
};

typedef struct function_call_node TinyOptFunctionCallNode_t;

struct function_call_node
{
  TinyOptASTNode_t base;
  char *name;
  struct ast_node *arguments;
};

typedef struct parameter_list_node TinyOptParameterListNode_t;

struct parameter_list_node
{
  TinyOptASTNode_t base;
  struct ast_node *parameters;
};

TinyOptASTNode_t *create_program_node ();
TinyOptASTNode_t *create_declaration_node (DataType type, char *name,
                                           TinyOptASTNode_t *init,
                                           int array_size, uint64_t hash);
TinyOptASTNode_t *create_assignment_node (char *var, Operator op,
                                          TinyOptASTNode_t *value,
                                          uint64_t hash);
TinyOptASTNode_t *create_expression_node (Operator op, TinyOptASTNode_t *left,
                                          TinyOptASTNode_t *right,
                                          char *value);
TinyOptASTNode_t *create_condition_node (Operator op, TinyOptASTNode_t *left,
                                         TinyOptASTNode_t *right);
TinyOptASTNode_t *create_if_node (TinyOptASTNode_t *condition,
                                  TinyOptASTNode_t *then_stmt,
                                  TinyOptASTNode_t *else_stmt);
TinyOptASTNode_t *create_while_node (TinyOptASTNode_t *condition,
                                     TinyOptASTNode_t *body,
                                     uint64_t loop_hash);
TinyOptASTNode_t *create_for_node (TinyOptASTNode_t *init,
                                   TinyOptASTNode_t *condition,
                                   TinyOptASTNode_t *increment,
                                   TinyOptASTNode_t *body, uint64_t loop_hash);
TinyOptASTNode_t *create_compound_node (TinyOptASTNode_t *statements);
TinyOptASTNode_t *create_return_node (TinyOptASTNode_t *value);
TinyOptASTNode_t *create_control_node (int is_break);
TinyOptASTNode_t *create_identifier_node (char *name, uint64_t hash);
TinyOptASTNode_t *create_number_node (char *value, DataType type);
TinyOptASTNode_t *create_char_literal_node (char *value);
TinyOptASTNode_t *create_string_literal_node (char *value);
TinyOptASTNode_t *create_binary_op_node (Operator op, TinyOptASTNode_t *left,
                                         TinyOptASTNode_t *right);
TinyOptASTNode_t *create_unary_op_node (Operator op,
                                        TinyOptASTNode_t *operand);
TinyOptASTNode_t *create_function_def_node (DataType return_type, char *name,
                                            TinyOptASTNode_t *parameters,
                                            TinyOptASTNode_t *body);
TinyOptASTNode_t *create_function_call_node (char *name,
                                             TinyOptASTNode_t *arguments);
TinyOptASTNode_t *create_parameter_list_node (TinyOptASTNode_t *parameters);

void add_statement (TinyOptASTNode_t *program, TinyOptASTNode_t *statement);
TinyOptASTNode_t *add_args (TinyOptASTNode_t *list, TinyOptASTNode_t *expr);
void free_ast (TinyOptASTNode_t *node);
void print_ast (TinyOptASTNode_t *node, int depth);

#endif // TINYOPT_AST_H
