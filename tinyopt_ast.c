/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni 
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_ast.h"

TinyOptASTNode_t *
create_program_node (void)
{
  TinyOptProgramNode_t *node = malloc (sizeof (TinyOptProgramNode_t));
  node->base.type = NODE_PROGRAM;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->statements = NULL;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_declaration_node (DataType type, char *name, TinyOptASTNode_t *init,
                         int array_size, uint64_t hash)
{
  TinyOptDeclarationNode_t *node = malloc (sizeof (TinyOptDeclarationNode_t));
  node->base.type = NODE_DECLARATION;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->data_type = type;
  node->name = strdup (name);
  node->hash = hash;
  node->initial_value = init;
  node->array_size = array_size;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_assignment_node (char *var, Operator op, TinyOptASTNode_t *value,
                        uint64_t hash)
{
  TinyOptAssignmentNode_t *node = malloc (sizeof (TinyOptAssignmentNode_t));
  node->base.type = NODE_ASSIGNMENT;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->variable = strdup (var);
  node->hash = hash;
  node->op = op;
  node->value = value;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_expression_node (Operator op, TinyOptASTNode_t *left,
                        TinyOptASTNode_t *right, char *value)
{
  TinyOptExpressionNode_t *node = malloc (sizeof (TinyOptExpressionNode_t));
  node->base.type = NODE_EXPRESSION;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->op = op;
  node->left = left;
  node->right = right;
  node->value = value ? strdup (value) : NULL;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_condition_node (Operator op, TinyOptASTNode_t *left,
                       TinyOptASTNode_t *right)
{
  TinyOptConditionNode_t *node = malloc (sizeof (TinyOptConditionNode_t));
  node->base.type = NODE_CONDITION;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->op = op;
  node->left = left;
  node->right = right;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_if_node (TinyOptASTNode_t *condition, TinyOptASTNode_t *then_stmt,
                TinyOptASTNode_t *else_stmt)
{
  TinyOptIfNode_t *node = malloc (sizeof (TinyOptIfNode_t));
  node->base.type = NODE_IF_STATEMENT;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->condition = condition;
  node->then_statement = then_stmt;
  node->else_statement = else_stmt;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_while_node (TinyOptASTNode_t *condition, TinyOptASTNode_t *body,
                   uint64_t loop_hash)
{
  TinyOptWhileNode_t *node = malloc (sizeof (TinyOptWhileNode_t));
  node->base.type = NODE_WHILE_STATEMENT;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->condition = condition;
  node->body = body;
  node->loop_hash = loop_hash;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_for_node (TinyOptASTNode_t *init, TinyOptASTNode_t *condition,
                 TinyOptASTNode_t *increment, TinyOptASTNode_t *body,
                 uint64_t loop_hash)
{
  TinyOptForNode_t *node = malloc (sizeof (TinyOptForNode_t));
  node->base.type = NODE_FOR_STATEMENT;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->init = init;
  node->condition = condition;
  node->increment = increment;
  node->body = body;
  node->loop_hash = loop_hash;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_compound_node (TinyOptASTNode_t *statements)
{
  TinyOptCompoundNode_t *node = malloc (sizeof (TinyOptCompoundNode_t));
  node->base.type = NODE_COMPOUND_STATEMENT;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->statements = statements;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_return_node (TinyOptASTNode_t *value)
{
  TinyOptReturnNode_t *node = malloc (sizeof (TinyOptReturnNode_t));
  node->base.type = NODE_RETURN;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->value = value;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_control_node (int is_break)
{
  TinyOptControlNode_t *node = malloc (sizeof (TinyOptControlNode_t));
  node->base.type = is_break ? NODE_BREAK : NODE_CONTINUE;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->is_break = is_break;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_identifier_node (char *name, uint64_t hash)
{
  TinyOptIdentifierNode_t *node = malloc (sizeof (TinyOptIdentifierNode_t));
  node->base.type = NODE_IDENTIFIER;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->name = strdup (name);
  node->hash = hash;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_number_node (char *value, DataType type)
{
  TinyOptNumberNode_t *node = malloc (sizeof (TinyOptNumberNode_t));
  node->base.type = NODE_NUMBER;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->value = strdup (value);
  node->data_type = type;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_char_literal_node (char *value)
{
  TinyOptCharLiteralNode_t *node = malloc (sizeof (TinyOptCharLiteralNode_t));
  node->base.type = NODE_CHAR_LITERAL;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->value = strdup (value);
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_string_literal_node (char *value)
{
  TinyOptStringLiteralNode_t *node
      = malloc (sizeof (TinyOptStringLiteralNode_t));
  node->base.type = NODE_STRING_LITERAL;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->value = strdup (value);
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_binary_op_node (Operator op, TinyOptASTNode_t *left,
                       TinyOptASTNode_t *right)
{
  TinyOptBinaryOpNode_t *node = malloc (sizeof (TinyOptBinaryOpNode_t));
  node->base.type = NODE_BINARY_OP;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->op = op;
  node->left = left;
  node->right = right;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_unary_op_node (Operator op, TinyOptASTNode_t *operand)
{
  TinyOptUnaryOpNode_t *node = malloc (sizeof (TinyOptUnaryOpNode_t));
  node->base.type = NODE_UNARY_OP;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->op = op;
  node->operand = operand;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_function_def_node (DataType return_type, char *name,
                          TinyOptASTNode_t *parameters, TinyOptASTNode_t *body)
{
  TinyOptFunctionDefNode_t *node = malloc (sizeof (TinyOptFunctionDefNode_t));
  node->base.type = NODE_FUNCTION_DEF;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->return_type = return_type;
  node->name = strdup (name);
  node->parameters = parameters;
  node->body = body;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_function_call_node (char *name, TinyOptASTNode_t *arguments)
{
  TinyOptFunctionCallNode_t *node
      = malloc (sizeof (TinyOptFunctionCallNode_t));
  node->base.type = NODE_FUNCTION_CALL;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->name = strdup (name);
  node->arguments = arguments;
  return (TinyOptASTNode_t *)node;
}

TinyOptASTNode_t *
create_parameter_list_node (TinyOptASTNode_t *parameters)
{
  TinyOptParameterListNode_t *node
      = malloc (sizeof (TinyOptParameterListNode_t));
  node->base.type = NODE_PARAMETER_LIST;
  node->base.next = NULL;
  node->base.parent = NULL;
  node->base.is_dead_code = 0;
  node->parameters = parameters;
  return (TinyOptASTNode_t *)node;
}

void
add_statement (TinyOptASTNode_t *program, TinyOptASTNode_t *statement)
{
  if (!program || program->type != NODE_PROGRAM)
    return;

  TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)program;
  if (!prog->statements)
    {
      prog->statements = statement;
    }
  else
    {
      TinyOptASTNode_t *cur = prog->statements;
      while (cur->next)
        cur = cur->next;
      cur->next = statement;
    }
}

TinyOptASTNode_t *
add_args (TinyOptASTNode_t *list, TinyOptASTNode_t *expr)
{
  if (!expr)
    return list;
  expr->next = NULL;

  if (!list)
    return expr;

  TinyOptASTNode_t *cur = list;
  while (cur->next)
    cur = cur->next;
  cur->next = expr;
  return list;
}

void
free_ast (TinyOptASTNode_t *node)
{
  if (!node)
    return;

  switch (node->type)
    {
    case NODE_PROGRAM:
      free_ast (((TinyOptProgramNode_t *)node)->statements);
      break;
    case NODE_DECLARATION:
      free (((TinyOptDeclarationNode_t *)node)->name);
      free_ast (((TinyOptDeclarationNode_t *)node)->initial_value);
      break;
    case NODE_ASSIGNMENT:
      free (((TinyOptAssignmentNode_t *)node)->variable);
      free_ast (((TinyOptAssignmentNode_t *)node)->value);
      break;
    case NODE_EXPRESSION:
      {
        TinyOptExpressionNode_t *expr = (TinyOptExpressionNode_t *)node;
        free_ast (expr->left);
        free_ast (expr->right);
        free (expr->value);
      }
      break;
    case NODE_CONDITION:
      free_ast (((TinyOptConditionNode_t *)node)->left);
      free_ast (((TinyOptConditionNode_t *)node)->right);
      break;
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)node;
        free_ast (ifn->condition);
        free_ast (ifn->then_statement);
        free_ast (ifn->else_statement);
      }
      break;
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *wn = (TinyOptWhileNode_t *)node;
        free_ast (wn->condition);
        free_ast (wn->body);
      }
      break;
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *fn = (TinyOptForNode_t *)node;
        free_ast (fn->init);
        free_ast (fn->condition);
        free_ast (fn->increment);
        free_ast (fn->body);
      }
      break;
    case NODE_COMPOUND_STATEMENT:
      free_ast (((TinyOptCompoundNode_t *)node)->statements);
      break;
    case NODE_RETURN:
      free_ast (((TinyOptReturnNode_t *)node)->value);
      break;
    case NODE_IDENTIFIER:
      free (((TinyOptIdentifierNode_t *)node)->name);
      break;
    case NODE_NUMBER:
      free (((TinyOptNumberNode_t *)node)->value);
      break;
    case NODE_CHAR_LITERAL:
      free (((TinyOptCharLiteralNode_t *)node)->value);
      break;
    case NODE_STRING_LITERAL:
      free (((TinyOptStringLiteralNode_t *)node)->value);
      break;
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *bin = (TinyOptBinaryOpNode_t *)node;
        free_ast (bin->left);
        free_ast (bin->right);
      }
      break;
    case NODE_UNARY_OP:
      free_ast (((TinyOptUnaryOpNode_t *)node)->operand);
      break;
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *fn = (TinyOptFunctionDefNode_t *)node;
        free (fn->name);
        free_ast (fn->parameters);
        free_ast (fn->body);
      }
      break;
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *fc = (TinyOptFunctionCallNode_t *)node;
        free (fc->name);
        free_ast (fc->arguments);
      }
      break;
    case NODE_PARAMETER_LIST:
      free_ast (((TinyOptParameterListNode_t *)node)->parameters);
      break;
    default:
      break;
    }

  free_ast (node->next);
  free (node);
}

void
print_ast (TinyOptASTNode_t *node, int depth)
{
  if (!node)
    return;

  for (int i = 0; i < depth; i++)
    printf ("  ");

  if (node->is_dead_code)
    printf ("[DEAD] ");

  switch (node->type)
    {
    case NODE_PROGRAM:
      printf ("Program\n");
      print_ast (((TinyOptProgramNode_t *)node)->statements, depth + 1);
      break;
    case NODE_DECLARATION:
      printf ("Declaration: %s\n", ((TinyOptDeclarationNode_t *)node)->name);
      print_ast (((TinyOptDeclarationNode_t *)node)->initial_value, depth + 1);
      break;
    case NODE_ASSIGNMENT:
      printf ("Assignment: %s\n", ((TinyOptAssignmentNode_t *)node)->variable);
      print_ast (((TinyOptAssignmentNode_t *)node)->value, depth + 1);
      break;
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)node;
        printf ("If Statement\n");
        print_ast (ifn->condition, depth + 1);
        print_ast (ifn->then_statement, depth + 1);
        if (ifn->else_statement)
          print_ast (ifn->else_statement, depth + 1);
      }
      break;
    case NODE_WHILE_STATEMENT:
      printf ("While Statement\n");
      print_ast (((TinyOptWhileNode_t *)node)->condition, depth + 1);
      print_ast (((TinyOptWhileNode_t *)node)->body, depth + 1);
      break;
    case NODE_FOR_STATEMENT:
      printf ("For Statement\n");
      print_ast (((TinyOptForNode_t *)node)->init, depth + 1);
      print_ast (((TinyOptForNode_t *)node)->condition, depth + 1);
      print_ast (((TinyOptForNode_t *)node)->increment, depth + 1);
      print_ast (((TinyOptForNode_t *)node)->body, depth + 1);
      break;
    case NODE_RETURN:
      printf ("Return\n");
      print_ast (((TinyOptReturnNode_t *)node)->value, depth + 1);
      break;
    case NODE_IDENTIFIER:
      printf ("Identifier: %s\n", ((TinyOptIdentifierNode_t *)node)->name);
      break;
    case NODE_NUMBER:
      printf ("Number: %s\n", ((TinyOptNumberNode_t *)node)->value);
      break;
    case NODE_STRING_LITERAL:
      printf ("String: %s\n", ((TinyOptStringLiteralNode_t *)node)->value);
      break;
    case NODE_CHAR_LITERAL:
      printf ("Char: %s\n", ((TinyOptCharLiteralNode_t *)node)->value);
      break;
    case NODE_FUNCTION_DEF:
      printf ("Function Definition: %s\n",
              ((TinyOptFunctionDefNode_t *)node)->name);
      break;
    case NODE_FUNCTION_CALL:
      printf ("Function Call: %s\n",
              ((TinyOptFunctionCallNode_t *)node)->name);
      break;
    case NODE_PARAMETER_LIST:
      printf ("Parameter List\n");
      print_ast (((TinyOptParameterListNode_t *)node)->parameters, depth + 1);
      break;
    default:
      printf ("Node type %d\n", node->type);
      break;
    }

  print_ast (node->next, depth);
}
