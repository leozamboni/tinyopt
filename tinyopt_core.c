/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni 
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_core.h"
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static int is_number_node (TinyOptASTNode_t *n);
static long parse_number_value (const char *s);
static TinyOptASTNode_t *make_number (long value);
static TinyOptASTNode_t *fold_expression (TinyOptASTNode_t *node);
static TinyOptASTNode_t *fold_condition (TinyOptASTNode_t *node);
static void fold_in_tree (TinyOptASTNode_t *node);
static int is_pure_expression (TinyOptASTNode_t *expr);
static long eval_relational (Operator op, long a, long b);
static long eval_binary (Operator op, long a, long b);

SymbolValue *evaluate_expression_value (TinyOptASTNode_t *expr,
                                        TinyOptStab_t *table, char *scope);

void
optimize (TinyOpt_t **tinyopt)
{
  constant_folding ((*tinyopt)->ast);

  set_symtab ((*tinyopt)->ast, (*tinyopt)->stab, 0, "global");

  reachability_analysis ((*tinyopt)->ast, (*tinyopt)->stab, "global");
  liveness_dse ((*tinyopt)->stab);
  empty_blocks ((*tinyopt)->ast);

  remove_dead_code ((*tinyopt)->ast);

  // print_dse_table(head);
  // print_optimization_report(ast);
}

void
constant_folding (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;
  fold_in_tree (node);
}

static int
is_number_node (TinyOptASTNode_t *n)
{
  return n && n->type == NODE_NUMBER;
}

static long
parse_number_value (const char *s)
{
  if (s == NULL)
    return 0;
  return strtol (s, NULL, 10);
}

static TinyOptASTNode_t *
make_number (long value)
{
  char buf[64];
  snprintf (buf, sizeof (buf), "%ld", value);
  return create_number_node (buf, TYPE_INT);
}

static int
is_pure_expression (TinyOptASTNode_t *expr)
{
  if (expr == NULL)
    return 1;
  switch (expr->type)
    {
    case NODE_NUMBER:
    case NODE_IDENTIFIER:
      return 1;
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *b = (TinyOptBinaryOpNode_t *)expr;
        return is_pure_expression (b->left) && is_pure_expression (b->right);
      }
    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *u = (TinyOptUnaryOpNode_t *)expr;
        return is_pure_expression (u->operand);
      }
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *c = (TinyOptConditionNode_t *)expr;
        return is_pure_expression (c->left) && is_pure_expression (c->right);
      }
    default:
      return 0;
    }
}

static long
eval_relational (Operator op, long a, long b)
{
  switch (op)
    {
    case OP_EQ:
      return a == b;
    case OP_NE:
      return a != b;
    case OP_LT:
      return a < b;
    case OP_LE:
      return a <= b;
    case OP_GT:
      return a > b;
    case OP_GE:
      return a >= b;
    case OP_OR:
      return a || b;
    default:
      return 0;
    }
}

static long
eval_binary (Operator op, long a, long b)
{
  switch (op)
    {
    case OP_ADD:
      return a + b;
    case OP_SUB:
      return a - b;
    case OP_MUL:
      return a * b;
    case OP_DIV:
      return b != 0 ? a / b : 0;
    case OP_MOD:
      return b != 0 ? a % b : 0;
    default:
      return 0;
    }
}

static TinyOptASTNode_t *
fold_condition (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return NULL;
  switch (node->type)
    {
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *c = (TinyOptConditionNode_t *)node;
        c->left = fold_expression (c->left);
        c->right = fold_expression (c->right);
        if (is_number_node (c->left) && is_number_node (c->right))
          {
            long a
                = parse_number_value (((TinyOptNumberNode_t *)c->left)->value);
            long b = parse_number_value (
                ((TinyOptNumberNode_t *)c->right)->value);
            long res = eval_relational (c->op, a, b);
            return make_number (res);
          }
        return node;
      }
    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *u = (TinyOptUnaryOpNode_t *)node;
        u->operand = fold_condition (u->operand);
        if (u->op == OP_NOT && is_number_node (u->operand))
          {
            long v = parse_number_value (
                ((TinyOptNumberNode_t *)u->operand)->value);
            return make_number (!v);
          }
        return node;
      }
    default:
      return fold_expression (node);
    }
}

static TinyOptASTNode_t *
fold_expression (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return NULL;
  switch (node->type)
    {
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *b = (TinyOptBinaryOpNode_t *)node;
        b->left = fold_expression (b->left);
        b->right = fold_expression (b->right);
        if (is_number_node (b->left) && is_number_node (b->right))
          {
            long a
                = parse_number_value (((TinyOptNumberNode_t *)b->left)->value);
            long c = parse_number_value (
                ((TinyOptNumberNode_t *)b->right)->value);
            long res = eval_binary (b->op, a, c);
            return make_number (res);
          }
        return node;
      }
    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *u = (TinyOptUnaryOpNode_t *)node;
        u->operand = fold_expression (u->operand);
        if (u->op == OP_NOT && is_number_node (u->operand))
          {
            long v = parse_number_value (
                ((TinyOptNumberNode_t *)u->operand)->value);
            return make_number (!v);
          }
        return node;
      }
    case NODE_CONDITION:
      return fold_condition (node);
    default:
      return node;
    }
}

static void
fold_in_tree (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;
  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *p = (TinyOptProgramNode_t *)node;
        fold_in_tree (p->statements);
        break;
      }
    case NODE_DECLARATION:
      {
        TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *)node;
        if (d->initial_value)
          d->initial_value = fold_expression (d->initial_value);
        break;
      }
    case NODE_ASSIGNMENT:
      {
        TinyOptAssignmentNode_t *a = (TinyOptAssignmentNode_t *)node;
        if (a->value)
          a->value = fold_expression (a->value);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *i = (TinyOptIfNode_t *)node;
        if (i->condition)
          i->condition = fold_condition (i->condition);
        fold_in_tree (i->then_statement);
        fold_in_tree (i->else_statement);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *w = (TinyOptWhileNode_t *)node;
        if (w->condition)
          w->condition = fold_condition (w->condition);
        fold_in_tree (w->body);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *f = (TinyOptForNode_t *)node;
        if (f->condition)
          f->condition = fold_condition (f->condition);
        fold_in_tree (f->init);
        fold_in_tree (f->increment);
        fold_in_tree (f->body);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *c = (TinyOptCompoundNode_t *)node;
        fold_in_tree (c->statements);
        break;
      }
    case NODE_RETURN:
      {
        TinyOptReturnNode_t *r = (TinyOptReturnNode_t *)node;
        if (r->value)
          r->value = fold_expression (r->value);
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        fold_in_tree (func->body);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        // Fazer fold nos argumentos
        if (call->arguments && call->arguments->type == NODE_PROGRAM)
          {
            TinyOptProgramNode_t *prog
                = (TinyOptProgramNode_t *)call->arguments;
            TinyOptASTNode_t *cur = prog->statements;
            while (cur)
              {
                TinyOptASTNode_t *next = cur->next;
                if (cur->type != NODE_DECLARATION)
                  {
                    TinyOptASTNode_t *folded = fold_expression (cur);
                    if (folded != cur)
                      {
                        // Substituir na lista (simplificado)
                      }
                  }
                cur = next;
              }
          }
        break;
      }
    default:
      break;
    }
  fold_in_tree (node->next);
}

void
mark_subtree_dead (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;

  node->is_dead_code = 1;

  switch (node->type)
    {
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)node;
        mark_subtree_dead (ifn->condition);
        mark_subtree_dead (ifn->then_statement);
        mark_subtree_dead (ifn->else_statement);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *wn = (TinyOptWhileNode_t *)node;
        mark_subtree_dead (wn->condition);
        mark_subtree_dead (wn->body);
        break;
      }
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *cn = (TinyOptConditionNode_t *)node;
        mark_subtree_dead (cn->left);
        mark_subtree_dead (cn->right);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *fn = (TinyOptForNode_t *)node;
        mark_subtree_dead (fn->init);
        mark_subtree_dead (fn->condition);
        mark_subtree_dead (fn->increment);
        mark_subtree_dead (fn->body);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        TinyOptASTNode_t *stmt = comp->statements;
        while (stmt)
          {
            mark_subtree_dead (stmt);
            stmt = stmt->next;
          }
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        mark_subtree_dead (func->body);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        mark_subtree_dead (call->arguments);
        break;
      }
    default:
      break;
    }

  // mark_subtree_dead(node->next);
}

int
eval_condition (TinyOptASTNode_t *condition, TinyOptStab_t *head, char *scope)
{
  if (!condition)
    return -1;

  SymbolValue *val = evaluate_expression_value (condition, head, scope);

  if (!val)
    return -1; // não foi possível resolver

  if (val->type == VALUE_TYPE_INT)
    {
      if (val->number != 0)
        return 1; // sempre verdadeiro
      else
        return 0; // sempre falso
    }

  return -1; // caso string
}

void
reachability_analysis (TinyOptASTNode_t *node, TinyOptStab_t *head,
                       char *scope)
{
  if (node == NULL)
    return;

  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)node;
        reachability_analysis (prog->statements, head, scope);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *if_node = (TinyOptIfNode_t *)node;
        int cond = eval_condition (if_node->condition, head, scope);
        if (cond == 1)
          {
            if (if_node->else_statement)
              {
                mark_subtree_dead (if_node->else_statement);
              }
          }
        else if (cond == 0)
          {
            if (if_node->condition)
              {
                mark_subtree_dead (if_node->condition);
              }
            if (if_node->then_statement)
              {
                mark_subtree_dead (if_node->then_statement);
              }
            if (!if_node->else_statement)
              {
                mark_subtree_dead (node);
              }
          }

        reachability_analysis (if_node->condition, head, scope);
        reachability_analysis (if_node->then_statement, head, scope);
        reachability_analysis (if_node->else_statement, head, scope);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *while_node = (TinyOptWhileNode_t *)node;
        int cond = eval_condition (while_node->condition, head, scope);

        if (cond == 0)
          {
            if (while_node->body)
              {
                mark_subtree_dead (while_node->body);
              }
            node->is_dead_code = 1;
          }

        reachability_analysis (while_node->condition, head, scope);
        reachability_analysis (while_node->body, head, scope);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *for_node = (TinyOptForNode_t *)node;

        if (for_node->condition)
          {
            int cond = eval_condition (for_node->condition, head, scope);
            if (cond == 0)
              {
                if (for_node->body)
                  {
                    mark_subtree_dead (for_node->body);
                  }
                node->is_dead_code = 1;
              }
          }

        reachability_analysis (for_node->init, head, scope);
        reachability_analysis (for_node->condition, head, scope);
        reachability_analysis (for_node->increment, head, scope);
        reachability_analysis (for_node->body, head, scope);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        if (comp->statements)
          {
            reachability_analysis (comp->statements, head, scope);
          }
        break;
      }
    case NODE_RETURN:
      {
        if (node->next)
          {
            mark_subtree_dead (node->next);
          }
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        reachability_analysis (func->body, head, func->name);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        reachability_analysis (call->arguments, head, scope);
        break;
      }
    case NODE_BREAK:
    case NODE_CONTINUE:
      {
        if (node->next)
          {
            mark_subtree_dead (node->next);
          }
        break;
      }
    default:
      break;
    }

  reachability_analysis (node->next, head, scope);
}

void
liveness_dse (TinyOptStab_t *table)
{
  if (!table)
    return;

  // Percorre todos os buckets da tabela
  for (size_t i = 0; i < table->size; i++)
    {
      SymbolBucket *bucket = table->buckets[i];
      while (bucket)
        {
          Symbol *entry = bucket->symbol;

          // CASO: n = n;
          if (entry->node->type == NODE_ASSIGNMENT)
            {
              TinyOptAssignmentNode_t *assig
                  = (TinyOptAssignmentNode_t *)entry->node;
              if (assig->value && assig->value->type == NODE_IDENTIFIER
                  && assig->op == OP_ASSIGN)
                {
                  TinyOptIdentifierNode_t *id
                      = (TinyOptIdentifierNode_t *)assig->value;
                  if (strcmp (id->name, assig->variable) == 0)
                    {
                      entry->node->is_dead_code = 1;
                      bucket = bucket->next;
                      continue;
                    }
                }
            }

          if (entry->node->type == NODE_DECLARATION
              || entry->node->type == NODE_ASSIGNMENT)
            {
              // Verifica se o símbolo é usado em outro lugar no mesmo escopo
              int used = 0;

              // Percorre todos os buckets novamente para procurar usos
              for (size_t j = 0; j < table->size && !used; j++)
                {
                  SymbolBucket *check_bucket = table->buckets[j];
                  while (check_bucket)
                    {
                      Symbol *check = check_bucket->symbol;
                      if (check != entry && check->name && entry->name
                          && strcmp (check->name, entry->name) == 0
                          && check->node && !check->node->is_dead_code
                          && check->node->type == NODE_IDENTIFIER)
                        {
                          used = 1;
                          break;
                        }
                      check_bucket = check_bucket->next;
                    }
                }

              if (!used)
                entry->node->is_dead_code = 1;
            }

          if (entry->node->type == NODE_ASSIGNMENT)
            {
              int overwritten = 0;

              // Busca outra atribuição que sobrescreve a atual
              for (size_t j = 0; j < table->size && !overwritten; j++)
                {
                  SymbolBucket *check_bucket = table->buckets[j];
                  while (check_bucket)
                    {
                      Symbol *check = check_bucket->symbol;
                      if (check != entry && check->name && entry->name
                          && strcmp (check->name, entry->name) == 0
                          && check->node && !check->node->is_dead_code
                          && check->node->type == NODE_ASSIGNMENT)
                        {
                          TinyOptAssignmentNode_t *assign
                              = (TinyOptAssignmentNode_t *)check->node;
                          if (assign->op == OP_ASSIGN)
                            {
                              if (entry->loop_hash && !check->loop_hash)
                                break;
                              entry->node->is_dead_code = 1;
                              overwritten = 1;
                            }
                          break;
                        }
                      check_bucket = check_bucket->next;
                    }
                }
            }

          bucket = bucket->next;
        }
    }
}

SymbolValue *
resolve_final_value (TinyOptStab_t *stab, const char *name, const char *scope)
{
  if (!stab || !name || !scope)
    return NULL;

  // Hash baseado no escopo
  uint64_t hash = stab_hash_string (scope);
  size_t index = hash % stab->size;

  SymbolBucket *bucket = stab->buckets[index];
  Symbol *last_match = NULL;

  // Percorre o bucket procurando o símbolo mais recente
  while (bucket)
    {
      Symbol *sym = bucket->symbol;
      if (sym && sym->name && strcmp (sym->name, name) == 0
          && !sym->node->is_dead_code)
        {
          last_match = sym;
          // Mantemos o último encontrado (ordem de inserção já garante isso se
          // você usou a versão com append)
        }
      bucket = bucket->next;
    }

  if (!last_match || !last_match->value)
    return NULL;

  SymbolValue *val = last_match->value;

  // Valor literal direto (int ou string)
  if (val->type == VALUE_TYPE_INT || val->type == VALUE_TYPE_STRING)
    return val;

  // Se for uma declaração cujo valor inicial é outro identificador, resolve
  // recursivamente
  if (last_match->node && last_match->node->type == NODE_DECLARATION)
    {
      TinyOptDeclarationNode_t *decl
          = (TinyOptDeclarationNode_t *)last_match->node;
      if (decl->initial_value && decl->initial_value->type == NODE_IDENTIFIER)
        {
          TinyOptIdentifierNode_t *id
              = (TinyOptIdentifierNode_t *)decl->initial_value;
          return resolve_final_value (stab, id->name, scope);
        }
    }

  return NULL;
}

SymbolValue *
evaluate_expression_value (TinyOptASTNode_t *expr, TinyOptStab_t *table,
                           char *scope)
{
  if (!expr)
    return NULL;

  switch (expr->type)
    {
    case NODE_NUMBER:
      {
        TinyOptNumberNode_t *num = (TinyOptNumberNode_t *)expr;
        SymbolValue *val = malloc (sizeof (SymbolValue));
        val->type = VALUE_TYPE_INT;
        val->number = atoi (num->value);
        return val;
      }

    case NODE_STRING_LITERAL:
      {
        TinyOptStringLiteralNode_t *str = (TinyOptStringLiteralNode_t *)expr;
        SymbolValue *val = malloc (sizeof (SymbolValue));
        val->type = VALUE_TYPE_STRING;
        val->str = str->value;
        return val;
      }

    case NODE_IDENTIFIER:
      {
        TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)expr;

        SymbolValue *r = malloc (sizeof (SymbolValue));
        return resolve_final_value (table, id->name, scope);
      }

    case NODE_CONDITION:
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *bin = (TinyOptBinaryOpNode_t *)expr;
        SymbolValue *left_val
            = evaluate_expression_value (bin->left, table, scope);
        SymbolValue *right_val
            = evaluate_expression_value (bin->right, table, scope);

        // CASO: ... || 1
        if (right_val && right_val->type == VALUE_TYPE_INT && bin->op == OP_OR
            && right_val->number > 0)
          {
            return right_val;
          }
        // CASO: 1 || ...
        if (left_val && left_val->type == VALUE_TYPE_INT && bin->op == OP_OR
            && left_val->number > 0)
          {
            return left_val;
          }

        // CASO: ... && 0
        if (right_val && right_val->type == VALUE_TYPE_INT && bin->op == OP_AND
            && right_val->number == 0)
          {
            return right_val;
          }
        // CASO: 0 && ...
        if (left_val && left_val->type == VALUE_TYPE_INT && bin->op == OP_AND
            && left_val->number == 0)
          {
            return left_val;
          }

        if (!left_val || !right_val)
          return NULL;

        // Só tratamos inteiros aqui — strings você pode definir outra
        // semântica depois
        if (left_val->type != VALUE_TYPE_INT
            || right_val->type != VALUE_TYPE_INT)
          return NULL;

        SymbolValue *result = malloc (sizeof (SymbolValue));
        result->type = VALUE_TYPE_INT;

        switch (bin->op)
          {
          case OP_ADD:
            result->number = left_val->number + right_val->number;
            break;
          case OP_SUB:
            result->number = left_val->number - right_val->number;
            break;
          case OP_MUL:
            result->number = left_val->number * right_val->number;
            break;
          case OP_DIV:
            result->number = (right_val->number != 0)
                                 ? left_val->number / right_val->number
                                 : 0;
            break;
            // case '%':
            //     result->number = (right_val->number != 0) ? left_val->number
            //     % right_val->number : 0; break;
          case OP_GT:
            result->number = left_val->number > right_val->number;
            break;
          case OP_LT:
            result->number = left_val->number < right_val->number;
            break;
          case OP_EQ:
            result->number = (left_val->number == right_val->number);
            break;
          case OP_AND:
            result->number = (left_val->number && right_val->number);
            break;
          case OP_OR:
            result->number = (left_val->number || right_val->number);
            break;
          default:
            free (result);
            result = NULL;
            break;
          }

        return result;
      }

    default:
      return NULL;
    }
}

#include "tinyopt_stab.h"

void
set_symtab (TinyOptASTNode_t *node, TinyOptStab_t *stab, uint64_t loop_hash,
            const char *scope)
{
  if (!node || !stab)
    return;

  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)node;
        set_symtab (prog->statements, stab, loop_hash, scope);
        break;
      }

    case NODE_DECLARATION:
      {
        TinyOptDeclarationNode_t *decl = (TinyOptDeclarationNode_t *)node;
        if (decl->name)
          {
            Symbol *sym = malloc (sizeof (Symbol));
            if (!sym)
              break;

            sym->node = node;
            sym->name = decl->name;
            sym->id_hash = decl->hash;
            sym->loop_hash = loop_hash;
            sym->value = NULL;

            if (decl->initial_value)
              {
                SymbolValue *val = evaluate_expression_value (
                    decl->initial_value, stab, scope);
                if (val)
                  {
                    sym->value = malloc (sizeof (SymbolValue));
                    memcpy (sym->value, val, sizeof (SymbolValue));
                  }
              }

            stab_insert (stab, sym, scope);
          }

        set_symtab (decl->initial_value, stab, loop_hash, scope);
        break;
      }

    case NODE_ASSIGNMENT:
      {
        TinyOptAssignmentNode_t *assign = (TinyOptAssignmentNode_t *)node;
        if (assign->variable)
          {
            Symbol *sym = malloc (sizeof (Symbol));
            if (!sym)
              break;

            sym->node = node;
            sym->name = assign->variable;
            sym->id_hash = assign->hash;
            sym->loop_hash = loop_hash;
            sym->value = NULL;

            if (assign->value)
              {
                SymbolValue *val
                    = evaluate_expression_value (assign->value, stab, scope);
                if (val)
                  {
                    sym->value = malloc (sizeof (SymbolValue));
                    memcpy (sym->value, val, sizeof (SymbolValue));
                  }
              }

            stab_insert (stab, sym, scope);
          }
        set_symtab (assign->value, stab, loop_hash, scope);
        break;
      }

    case NODE_IDENTIFIER:
      {
        TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)node;
        if (id->name)
          {
            SymbolValue *val = resolve_final_value (stab, id->name, scope);

            Symbol *sym = malloc (sizeof (Symbol));
            if (!sym)
              break;

            sym->node = node;
            sym->name = id->name;
            sym->id_hash = id->hash;
            sym->loop_hash = loop_hash;
            sym->value = NULL;

            if (val)
              {
                sym->value = malloc (sizeof (SymbolValue));
                memcpy (sym->value, val, sizeof (SymbolValue));
              }

            stab_insert (stab, sym, scope);
          }
        break;
      }

    case NODE_EXPRESSION:
      {
        TinyOptExpressionNode_t *expr = (TinyOptExpressionNode_t *)node;
        set_symtab (expr->left, stab, loop_hash, scope);
        set_symtab (expr->right, stab, loop_hash, scope);
        break;
      }

    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *cond = (TinyOptConditionNode_t *)node;
        set_symtab (cond->left, stab, loop_hash, scope);
        set_symtab (cond->right, stab, loop_hash, scope);
        break;
      }

    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *if_node = (TinyOptIfNode_t *)node;
        set_symtab (if_node->condition, stab, loop_hash, scope);
        set_symtab (if_node->then_statement, stab, loop_hash, scope);
        set_symtab (if_node->else_statement, stab, loop_hash, scope);
        break;
      }

    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *while_node = (TinyOptWhileNode_t *)node;
        set_symtab (while_node->condition, stab, while_node->loop_hash, scope);
        set_symtab (while_node->body, stab, while_node->loop_hash, scope);
        break;
      }

    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *for_node = (TinyOptForNode_t *)node;
        set_symtab (for_node->init, stab, for_node->loop_hash, scope);
        set_symtab (for_node->condition, stab, for_node->loop_hash, scope);
        set_symtab (for_node->increment, stab, for_node->loop_hash, scope);
        set_symtab (for_node->body, stab, for_node->loop_hash, scope);
        break;
      }

    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        if (comp->statements)
          set_symtab (comp->statements, stab, loop_hash, scope);
        break;
      }

    case NODE_RETURN:
      {
        TinyOptReturnNode_t *ret = (TinyOptReturnNode_t *)node;
        set_symtab (ret->value, stab, loop_hash, scope);
        break;
      }

    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        set_symtab (func->parameters, stab, loop_hash, func->name);
        set_symtab (func->body, stab, loop_hash, func->name);
        break;
      }

    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        set_symtab (call->arguments, stab, loop_hash, scope);
        break;
      }

    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *bin = (TinyOptBinaryOpNode_t *)node;
        set_symtab (bin->left, stab, loop_hash, scope);
        set_symtab (bin->right, stab, loop_hash, scope);
        break;
      }

    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *unary = (TinyOptUnaryOpNode_t *)node;
        set_symtab (unary->operand, stab, loop_hash, scope);
        break;
      }

    default:
      break;
    }

  // percorre o próximo nó
  set_symtab (node->next, stab, loop_hash, scope);
}

int
all_statements_dead (TinyOptASTNode_t *stmt_list)
{
  TinyOptASTNode_t *current = stmt_list;

  while (current)
    {
      if (!current->is_dead_code)
        return 0; // encontrou um statement vivo
      current = current->next;
    }

  return 1; // se não encontrou nenhum, considera vazio (morto também)
}

void
empty_blocks (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;

  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)node;
        empty_blocks (prog->statements);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        if (comp->statements == NULL)
          {
            node->is_dead_code = 1;
          }
        else
          {
            empty_blocks (comp->statements);
            if (all_statements_dead (comp->statements))
              node->is_dead_code = 1;
          }
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *i = (TinyOptIfNode_t *)node;
        empty_blocks (i->then_statement);
        empty_blocks (i->else_statement);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *w = (TinyOptWhileNode_t *)node;
        empty_blocks (w->body);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *f = (TinyOptForNode_t *)node;
        empty_blocks (f->body);
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        empty_blocks (func->body);
        break;
      }
    default:
      break;
    }

  empty_blocks (node->next);
}

int
has_return_statement (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return 0;

  if (node->type == NODE_RETURN)
    return 1;

  return has_return_statement (node->next);
}

int
has_break_continue (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return 0;

  if (node->type == NODE_BREAK || node->type == NODE_CONTINUE)
    return 1;

  return has_break_continue (node->next);
}

void
print_optimization_report (TinyOptASTNode_t *ast)
{
  printf ("\n=== Relatório de Otimização ===\n");
  printf ("Árvore Sintática Abstrata após otimização:\n");
  print_ast (ast, 0);
  printf ("\n");
}

static void prune_list (TinyOptASTNode_t **head_ref);
static void prune_children (TinyOptASTNode_t *node);

void
remove_dead_code (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;
  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)node;
        prune_list (&prog->statements);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        prune_list (&comp->statements);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)node;
        prune_children (ifn->then_statement);
        prune_children (ifn->else_statement);
        if (ifn->condition)
          remove_dead_code (ifn->condition);
        if (ifn->then_statement)
          remove_dead_code (ifn->then_statement);
        if (ifn->else_statement)
          remove_dead_code (ifn->else_statement);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *wn = (TinyOptWhileNode_t *)node;
        prune_children (wn->body);
        if (wn->condition)
          remove_dead_code (wn->condition);
        if (wn->body)
          remove_dead_code (wn->body);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *fn = (TinyOptForNode_t *)node;
        prune_children (fn->init);
        prune_children (fn->increment);
        prune_children (fn->body);
        if (fn->condition)
          remove_dead_code (fn->condition);
        if (fn->init)
          remove_dead_code (fn->init);
        if (fn->increment)
          remove_dead_code (fn->increment);
        if (fn->body)
          remove_dead_code (fn->body);
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        if (func->body)
          {
            if (func->body->type == NODE_COMPOUND_STATEMENT)
              {
                TinyOptCompoundNode_t *comp
                    = (TinyOptCompoundNode_t *)func->body;
                prune_list (&comp->statements);
              }
            remove_dead_code (func->body);
          }
        break;
      }
    default:
      break;
    }
}

static void
prune_children (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;
  if (node->type == NODE_COMPOUND_STATEMENT)
    {
      TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
      prune_list (&comp->statements);
    }
}

static void
prune_list (TinyOptASTNode_t **head_ref)
{
  if (head_ref == NULL)
    return;
  TinyOptASTNode_t *current = *head_ref;
  TinyOptASTNode_t *previous = NULL;
  while (current)
    {
      if (current->is_dead_code)
        {
          TinyOptASTNode_t *to_free = current;
          current = current->next;
          if (previous)
            {
              previous->next = current;
            }
          else
            {
              *head_ref = current;
            }
          to_free->next = NULL;
          free_ast (to_free);
          continue;
        }
      switch (current->type)
        {
        case NODE_IF_STATEMENT:
          {
            TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)current;
            prune_children (ifn->then_statement);
            prune_children (ifn->else_statement);
            if (ifn->then_statement)
              remove_dead_code (ifn->then_statement);
            if (ifn->else_statement)
              remove_dead_code (ifn->else_statement);
            if (ifn->condition)
              remove_dead_code (ifn->condition);

            if (ifn->then_statement && ifn->then_statement->is_dead_code)
              {
                free_ast (ifn->condition);
                free_ast (ifn->then_statement);
                ifn->then_statement = NULL;
                ifn->condition = NULL;
              }
            if (ifn->else_statement && ifn->else_statement->is_dead_code)
              {
                free_ast (ifn->else_statement);
                ifn->else_statement = NULL;
              }

            break;
          }
        case NODE_WHILE_STATEMENT:
          {
            TinyOptWhileNode_t *wn = (TinyOptWhileNode_t *)current;
            prune_children (wn->body);
            if (wn->body)
              remove_dead_code (wn->body);
            if (wn->condition)
              remove_dead_code (wn->condition);
            break;
          }
        case NODE_FOR_STATEMENT:
          {
            TinyOptForNode_t *fn = (TinyOptForNode_t *)current;
            prune_children (fn->init);
            prune_children (fn->increment);
            prune_children (fn->body);
            if (fn->init)
              remove_dead_code (fn->init);
            if (fn->increment)
              remove_dead_code (fn->increment);
            if (fn->body)
              remove_dead_code (fn->body);
            if (fn->condition)
              remove_dead_code (fn->condition);
            break;
          }
        case NODE_COMPOUND_STATEMENT:
          {
            TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)current;
            prune_list (&comp->statements);
            break;
          }
        case NODE_FUNCTION_DEF:
          {
            TinyOptFunctionDefNode_t *func
                = (TinyOptFunctionDefNode_t *)current;
            if (func->body)
              {
                if (func->body->type == NODE_COMPOUND_STATEMENT)
                  {
                    TinyOptCompoundNode_t *comp
                        = (TinyOptCompoundNode_t *)func->body;
                    prune_list (&comp->statements);
                  }
                remove_dead_code (func->body);
              }
            break;
          }
        default:
          break;
        }
      previous = current;
      current = current->next;
    }
}