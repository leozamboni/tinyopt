/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_core.h"
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void prune_list (TinyOptASTNode_t **head_ref);
static void prune_children (TinyOptASTNode_t *node);

SymbolValue *evaluate_expression_value (TinyOptASTNode_t *expr,
                                        TinyOptStab_t *table, char *scope);
SymbolValue *resolve_final_value (TinyOptStab_t *stab, const char *name,
                                  const char *scope);

void
tinyopt_optimize (TinyOpt_t **tinyopt)
{
  tinyopt_constant_folding ((*tinyopt)->ast);

  tinyopt_stab_init ((*tinyopt)->ast, (*tinyopt)->stab, 0, "global");

  tinyopt_reachability ((*tinyopt)->ast, (*tinyopt)->stab, "global");
  tinyopt_liveness ((*tinyopt)->stab);
  tinyopt_dead_store ((*tinyopt)->stab);
  tinyopt_empty_blocks ((*tinyopt)->ast);

  tinyopt_remove_dead_code ((*tinyopt)->ast);
}

void
tinyopt_remove_dead_code (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;
  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)node;
        prune_list (&prog->statements);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        prune_list (&comp->statements);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)node;
        prune_children (ifn->then_statement);
        prune_children (ifn->else_statement);
        if (ifn->condition)
          tinyopt_remove_dead_code (ifn->condition);
        if (ifn->then_statement)
          tinyopt_remove_dead_code (ifn->then_statement);
        if (ifn->else_statement)
          tinyopt_remove_dead_code (ifn->else_statement);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *wn = (TinyOptWhileNode_t *)node;
        prune_children (wn->body);
        if (wn->condition)
          tinyopt_remove_dead_code (wn->condition);
        if (wn->body)
          tinyopt_remove_dead_code (wn->body);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *fn = (TinyOptForNode_t *)node;
        prune_children (fn->init);
        prune_children (fn->increment);
        prune_children (fn->body);
        if (fn->condition)
          tinyopt_remove_dead_code (fn->condition);
        if (fn->init)
          tinyopt_remove_dead_code (fn->init);
        if (fn->increment)
          tinyopt_remove_dead_code (fn->increment);
        if (fn->body)
          tinyopt_remove_dead_code (fn->body);
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        if (func->body)
          {
            if (func->body->type == NODE_COMPOUND_STATEMENT)
              {
                TinyOptCompoundNode_t *comp
                    = (TinyOptCompoundNode_t *)func->body;
                prune_list (&comp->statements);
              }
            tinyopt_remove_dead_code (func->body);
          }
        break;
      }
    default:
      break;
    }
}

static void
prune_children (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;
  if (node->type == NODE_COMPOUND_STATEMENT)
    {
      TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
      prune_list (&comp->statements);
    }
}

static void
prune_list (TinyOptASTNode_t **head_ref)
{
  if (head_ref == NULL)
    return;
  TinyOptASTNode_t *current = *head_ref;
  TinyOptASTNode_t *previous = NULL;
  while (current)
    {
      if (current->is_dead_code)
        {
          TinyOptASTNode_t *to_free = current;
          current = current->next;
          if (previous)
            {
              previous->next = current;
            }
          else
            {
              *head_ref = current;
            }
          to_free->next = NULL;
          free_ast (to_free);
          continue;
        }
      switch (current->type)
        {
        case NODE_IF_STATEMENT:
          {
            TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)current;
            prune_children (ifn->then_statement);
            prune_children (ifn->else_statement);
            if (ifn->then_statement)
              tinyopt_remove_dead_code (ifn->then_statement);
            if (ifn->else_statement)
              tinyopt_remove_dead_code (ifn->else_statement);
            if (ifn->condition)
              tinyopt_remove_dead_code (ifn->condition);

            if (ifn->then_statement && ifn->then_statement->is_dead_code)
              {
                free_ast (ifn->condition);
                free_ast (ifn->then_statement);
                ifn->then_statement = NULL;
                ifn->condition = NULL;
              }
            if (ifn->else_statement && ifn->else_statement->is_dead_code)
              {
                free_ast (ifn->else_statement);
                ifn->else_statement = NULL;
              }

            break;
          }
        case NODE_WHILE_STATEMENT:
          {
            TinyOptWhileNode_t *wn = (TinyOptWhileNode_t *)current;
            prune_children (wn->body);
            if (wn->body)
              tinyopt_remove_dead_code (wn->body);
            if (wn->condition)
              tinyopt_remove_dead_code (wn->condition);
            break;
          }
        case NODE_FOR_STATEMENT:
          {
            TinyOptForNode_t *fn = (TinyOptForNode_t *)current;
            prune_children (fn->init);
            prune_children (fn->condition);
            prune_children (fn->increment);
            prune_children (fn->body);
            if (fn->init)
              tinyopt_remove_dead_code (fn->init);
            if (fn->increment)
              tinyopt_remove_dead_code (fn->increment);
            if (fn->body)
              tinyopt_remove_dead_code (fn->body);
            if (fn->condition)
              tinyopt_remove_dead_code (fn->condition);
            break;
          }
        case NODE_COMPOUND_STATEMENT:
          {
            TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)current;
            prune_list (&comp->statements);
            break;
          }
        case NODE_FUNCTION_DEF:
          {
            TinyOptFunctionDefNode_t *func
                = (TinyOptFunctionDefNode_t *)current;
            if (func->body)
              {
                if (func->body->type == NODE_COMPOUND_STATEMENT)
                  {
                    TinyOptCompoundNode_t *comp
                        = (TinyOptCompoundNode_t *)func->body;
                    prune_list (&comp->statements);
                  }
                tinyopt_remove_dead_code (func->body);
              }
            break;
          }
        default:
          break;
        }
      previous = current;
      current = current->next;
    }
}