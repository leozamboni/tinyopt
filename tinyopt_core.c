/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_core.h"
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

static void prune_list (TinyOptASTNode_t **head_ref);
static void prune_children (TinyOptASTNode_t *node);

SymbolValue *evaluate_expression_value (TinyOptASTNode_t *expr,
                                        TinyOptStab_t *table, char *scope);
SymbolValue *resolve_final_value (TinyOptStab_t *stab, const char *name,
                                  const char *scope);

void
optimize (TinyOpt_t **tinyopt)
{
  tinyopt_constant_folding ((*tinyopt)->ast);

  set_symtab ((*tinyopt)->ast, (*tinyopt)->stab, 0, "global");

  tinyopt_reachability ((*tinyopt)->ast, (*tinyopt)->stab, "global");
  tinyopt_liveness ((*tinyopt)->stab);
  tinyopt_dead_store ((*tinyopt)->stab);
  tinyopt_empty_blocks ((*tinyopt)->ast);

  remove_dead_code ((*tinyopt)->ast);
}

void
set_symtab (TinyOptASTNode_t *node, TinyOptStab_t *stab, uint64_t loop_hash,
            const char *scope)
{
  if (!node || !stab)
    return;

  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)node;
        set_symtab (prog->statements, stab, loop_hash, scope);
        break;
      }

    case NODE_DECLARATION:
      {
        TinyOptDeclarationNode_t *decl = (TinyOptDeclarationNode_t *)node;
        if (decl->name)
          {
            Symbol *sym = malloc (sizeof (Symbol));
            if (!sym)
              break;

            sym->node = node;
            sym->name = decl->name;
            sym->id_hash = decl->hash;
            sym->loop_hash = loop_hash;
            sym->value = NULL;

            if (decl->initial_value)
              {
                SymbolValue *val = evaluate_expression_value (
                    decl->initial_value, stab, scope);
                if (val)
                  {
                    sym->value = malloc (sizeof (SymbolValue));
                    memcpy (sym->value, val, sizeof (SymbolValue));
                  }
              }

            stab_insert (stab, sym, scope);
          }

        // set_symtab (decl->initial_value, stab, loop_hash, scope);
        break;
      }

    case NODE_ASSIGNMENT:
      {
        TinyOptAssignmentNode_t *assign = (TinyOptAssignmentNode_t *)node;
        if (assign->variable)
          {
            Symbol *sym = malloc (sizeof (Symbol));
            if (!sym)
              break;

            sym->node = node;
            sym->name = assign->variable;
            sym->id_hash = assign->hash;
            sym->loop_hash = loop_hash;
            sym->value = NULL;

            if (assign->value)
              {
                SymbolValue *val
                    = evaluate_expression_value (assign->value, stab, scope);
                if (val)
                  {
                    sym->value = malloc (sizeof (SymbolValue));
                    memcpy (sym->value, val, sizeof (SymbolValue));
                  }
              }

            stab_insert (stab, sym, scope);
          }
        // set_symtab (assign->value, stab, loop_hash, scope);
        break;
      }

    case NODE_IDENTIFIER:
      {
        TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)node;
        if (id->name)
          {
            SymbolValue *val = resolve_final_value (stab, id->name, scope);

            Symbol *sym = malloc (sizeof (Symbol));
            if (!sym)
              break;

            sym->node = node;
            sym->name = id->name;
            sym->id_hash = id->hash;
            sym->loop_hash = loop_hash;
            sym->value = NULL;

            if (val)
              {
                sym->value = malloc (sizeof (SymbolValue));
                memcpy (sym->value, val, sizeof (SymbolValue));
              }

            stab_insert (stab, sym, scope);
          }
        break;
      }

    case NODE_EXPRESSION:
      {
        TinyOptExpressionNode_t *expr = (TinyOptExpressionNode_t *)node;
        set_symtab (expr->left, stab, loop_hash, scope);
        set_symtab (expr->right, stab, loop_hash, scope);
        break;
      }

    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *cond = (TinyOptConditionNode_t *)node;
        set_symtab (cond->left, stab, loop_hash, scope);
        set_symtab (cond->right, stab, loop_hash, scope);
        break;
      }

    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *if_node = (TinyOptIfNode_t *)node;
        set_symtab (if_node->condition, stab, loop_hash, scope);
        set_symtab (if_node->then_statement, stab, loop_hash, scope);
        set_symtab (if_node->else_statement, stab, loop_hash, scope);
        break;
      }

    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *while_node = (TinyOptWhileNode_t *)node;
        set_symtab (while_node->condition, stab, while_node->loop_hash, scope);
        set_symtab (while_node->body, stab, while_node->loop_hash, scope);
        break;
      }

    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *for_node = (TinyOptForNode_t *)node;
        set_symtab (for_node->init, stab, for_node->loop_hash, scope);
        set_symtab (for_node->condition, stab, for_node->loop_hash, scope);
        set_symtab (for_node->increment, stab, for_node->loop_hash, scope);
        set_symtab (for_node->body, stab, for_node->loop_hash, scope);
        break;
      }

    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        if (comp->statements)
          set_symtab (comp->statements, stab, loop_hash, scope);
        break;
      }

    case NODE_RETURN:
      {
        TinyOptReturnNode_t *ret = (TinyOptReturnNode_t *)node;
        set_symtab (ret->value, stab, loop_hash, scope);
        break;
      }

    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        set_symtab (func->parameters, stab, loop_hash, func->name);
        set_symtab (func->body, stab, loop_hash, func->name);
        break;
      }

    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        set_symtab (call->arguments, stab, loop_hash, scope);
        break;
      }

    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *bin = (TinyOptBinaryOpNode_t *)node;
        set_symtab (bin->left, stab, loop_hash, scope);
        set_symtab (bin->right, stab, loop_hash, scope);
        break;
      }

    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *unary = (TinyOptUnaryOpNode_t *)node;
        set_symtab (unary->operand, stab, loop_hash, scope);
        break;
      }

    default:
      break;
    }

  // percorre o próximo nó
  set_symtab (node->next, stab, loop_hash, scope);
}

void
remove_dead_code (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;
  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)node;
        prune_list (&prog->statements);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        prune_list (&comp->statements);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)node;
        prune_children (ifn->then_statement);
        prune_children (ifn->else_statement);
        if (ifn->condition)
          remove_dead_code (ifn->condition);
        if (ifn->then_statement)
          remove_dead_code (ifn->then_statement);
        if (ifn->else_statement)
          remove_dead_code (ifn->else_statement);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *wn = (TinyOptWhileNode_t *)node;
        prune_children (wn->body);
        if (wn->condition)
          remove_dead_code (wn->condition);
        if (wn->body)
          remove_dead_code (wn->body);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *fn = (TinyOptForNode_t *)node;
        prune_children (fn->init);
        prune_children (fn->increment);
        prune_children (fn->body);
        if (fn->condition)
          remove_dead_code (fn->condition);
        if (fn->init)
          remove_dead_code (fn->init);
        if (fn->increment)
          remove_dead_code (fn->increment);
        if (fn->body)
          remove_dead_code (fn->body);
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        if (func->body)
          {
            if (func->body->type == NODE_COMPOUND_STATEMENT)
              {
                TinyOptCompoundNode_t *comp
                    = (TinyOptCompoundNode_t *)func->body;
                prune_list (&comp->statements);
              }
            remove_dead_code (func->body);
          }
        break;
      }
    default:
      break;
    }
}

static void
prune_children (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;
  if (node->type == NODE_COMPOUND_STATEMENT)
    {
      TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
      prune_list (&comp->statements);
    }
}

static void
prune_list (TinyOptASTNode_t **head_ref)
{
  if (head_ref == NULL)
    return;
  TinyOptASTNode_t *current = *head_ref;
  TinyOptASTNode_t *previous = NULL;
  while (current)
    {
      if (current->is_dead_code)
        {
          TinyOptASTNode_t *to_free = current;
          current = current->next;
          if (previous)
            {
              previous->next = current;
            }
          else
            {
              *head_ref = current;
            }
          to_free->next = NULL;
          free_ast (to_free);
          continue;
        }
      switch (current->type)
        {
        case NODE_IF_STATEMENT:
          {
            TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)current;
            prune_children (ifn->then_statement);
            prune_children (ifn->else_statement);
            if (ifn->then_statement)
              remove_dead_code (ifn->then_statement);
            if (ifn->else_statement)
              remove_dead_code (ifn->else_statement);
            if (ifn->condition)
              remove_dead_code (ifn->condition);

            if (ifn->then_statement && ifn->then_statement->is_dead_code)
              {
                free_ast (ifn->condition);
                free_ast (ifn->then_statement);
                ifn->then_statement = NULL;
                ifn->condition = NULL;
              }
            if (ifn->else_statement && ifn->else_statement->is_dead_code)
              {
                free_ast (ifn->else_statement);
                ifn->else_statement = NULL;
              }

            break;
          }
        case NODE_WHILE_STATEMENT:
          {
            TinyOptWhileNode_t *wn = (TinyOptWhileNode_t *)current;
            prune_children (wn->body);
            if (wn->body)
              remove_dead_code (wn->body);
            if (wn->condition)
              remove_dead_code (wn->condition);
            break;
          }
        case NODE_FOR_STATEMENT:
          {
            TinyOptForNode_t *fn = (TinyOptForNode_t *)current;
            prune_children (fn->init);
            prune_children (fn->condition);
            prune_children (fn->increment);
            prune_children (fn->body);
            if (fn->init)
              remove_dead_code (fn->init);
            if (fn->increment)
              remove_dead_code (fn->increment);
            if (fn->body)
              remove_dead_code (fn->body);
            if (fn->condition)
              remove_dead_code (fn->condition);
            break;
          }
        case NODE_COMPOUND_STATEMENT:
          {
            TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)current;
            prune_list (&comp->statements);
            break;
          }
        case NODE_FUNCTION_DEF:
          {
            TinyOptFunctionDefNode_t *func
                = (TinyOptFunctionDefNode_t *)current;
            if (func->body)
              {
                if (func->body->type == NODE_COMPOUND_STATEMENT)
                  {
                    TinyOptCompoundNode_t *comp
                        = (TinyOptCompoundNode_t *)func->body;
                    prune_list (&comp->statements);
                  }
                remove_dead_code (func->body);
              }
            break;
          }
        default:
          break;
        }
      previous = current;
      current = current->next;
    }
}