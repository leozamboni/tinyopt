/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_folding.h"

static void fold_in_tree (TinyOptASTNode_t *node);
static int is_number_node (TinyOptASTNode_t *n);
static long parse_number_value (const char *s);
static TinyOptASTNode_t *make_number (long value);
static int is_pure_expression (TinyOptASTNode_t *expr);
static long eval_relational (Operator op, long a, long b);
static long eval_binary (Operator op, long a, long b);
static TinyOptASTNode_t *fold_condition (TinyOptASTNode_t *node);
static TinyOptASTNode_t *fold_expression (TinyOptASTNode_t *node);

void
tinyopt_constant_folding (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;
  fold_in_tree (node);
}

static void
fold_in_tree (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;
  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *p = (TinyOptProgramNode_t *)node;
        fold_in_tree (p->statements);
        break;
      }
    case NODE_DECLARATION:
      {
        TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *)node;
        if (d->initial_value)
          d->initial_value = fold_expression (d->initial_value);
        break;
      }
    case NODE_ASSIGNMENT:
      {
        TinyOptAssignmentNode_t *a = (TinyOptAssignmentNode_t *)node;
        if (a->value)
          a->value = fold_expression (a->value);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *i = (TinyOptIfNode_t *)node;
        if (i->condition)
          i->condition = fold_condition (i->condition);
        fold_in_tree (i->then_statement);
        fold_in_tree (i->else_statement);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *w = (TinyOptWhileNode_t *)node;
        if (w->condition)
          w->condition = fold_condition (w->condition);
        fold_in_tree (w->body);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *f = (TinyOptForNode_t *)node;
        if (f->condition)
          f->condition = fold_condition (f->condition);
        fold_in_tree (f->init);
        fold_in_tree (f->increment);
        fold_in_tree (f->body);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *c = (TinyOptCompoundNode_t *)node;
        fold_in_tree (c->statements);
        break;
      }
    case NODE_RETURN:
      {
        TinyOptReturnNode_t *r = (TinyOptReturnNode_t *)node;
        if (r->value)
          r->value = fold_expression (r->value);
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        fold_in_tree (func->body);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        // Fazer fold nos argumentos
        if (call->arguments && call->arguments->type == NODE_PROGRAM)
          {
            TinyOptProgramNode_t *prog
                = (TinyOptProgramNode_t *)call->arguments;
            TinyOptASTNode_t *cur = prog->statements;
            while (cur)
              {
                TinyOptASTNode_t *next = cur->next;
                if (cur->type != NODE_DECLARATION)
                  {
                    TinyOptASTNode_t *folded = fold_expression (cur);
                    if (folded != cur)
                      {
                        // Substituir na lista (simplificado)
                      }
                  }
                cur = next;
              }
          }
        break;
      }
    default:
      break;
    }
  fold_in_tree (node->next);
}

static int
is_number_node (TinyOptASTNode_t *n)
{
  return n && n->type == NODE_NUMBER;
}

static long
parse_number_value (const char *s)
{
  if (s == NULL)
    return 0;
  return strtol (s, NULL, 10);
}

static TinyOptASTNode_t *
make_number (long value)
{
  char buf[64];
  snprintf (buf, sizeof (buf), "%ld", value);
  return create_number_node (buf, TYPE_INT);
}

static int
is_pure_expression (TinyOptASTNode_t *expr)
{
  if (expr == NULL)
    return 1;
  switch (expr->type)
    {
    case NODE_NUMBER:
    case NODE_IDENTIFIER:
      return 1;
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *b = (TinyOptBinaryOpNode_t *)expr;
        return is_pure_expression (b->left) && is_pure_expression (b->right);
      }
    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *u = (TinyOptUnaryOpNode_t *)expr;
        return is_pure_expression (u->operand);
      }
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *c = (TinyOptConditionNode_t *)expr;
        return is_pure_expression (c->left) && is_pure_expression (c->right);
      }
    default:
      return 0;
    }
}

static long
eval_relational (Operator op, long a, long b)
{
  switch (op)
    {
    case OP_EQ:
      return a == b;
    case OP_NE:
      return a != b;
    case OP_LT:
      return a < b;
    case OP_LE:
      return a <= b;
    case OP_GT:
      return a > b;
    case OP_GE:
      return a >= b;
    case OP_OR:
      return a || b;
    default:
      return 0;
    }
}

static long
eval_binary (Operator op, long a, long b)
{
  switch (op)
    {
    case OP_ADD:
      return a + b;
    case OP_SUB:
      return a - b;
    case OP_MUL:
      return a * b;
    case OP_DIV:
      return b != 0 ? a / b : 0;
    case OP_MOD:
      return b != 0 ? a % b : 0;
    default:
      return 0;
    }
}

static TinyOptASTNode_t *
fold_condition (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return NULL;
  switch (node->type)
    {
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *c = (TinyOptConditionNode_t *)node;
        c->left = fold_expression (c->left);
        c->right = fold_expression (c->right);
        if (is_number_node (c->left) && is_number_node (c->right))
          {
            long a
                = parse_number_value (((TinyOptNumberNode_t *)c->left)->value);
            long b = parse_number_value (
                ((TinyOptNumberNode_t *)c->right)->value);
            long res = eval_relational (c->op, a, b);
            return make_number (res);
          }
        return node;
      }
    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *u = (TinyOptUnaryOpNode_t *)node;
        u->operand = fold_condition (u->operand);
        if (u->op == OP_NOT && is_number_node (u->operand))
          {
            long v = parse_number_value (
                ((TinyOptNumberNode_t *)u->operand)->value);
            return make_number (!v);
          }
        return node;
      }
    default:
      return fold_expression (node);
    }
}

static TinyOptASTNode_t *
fold_expression (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return NULL;
  switch (node->type)
    {
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *b = (TinyOptBinaryOpNode_t *)node;
        b->left = fold_expression (b->left);
        b->right = fold_expression (b->right);
        if (is_number_node (b->left) && is_number_node (b->right))
          {
            long a
                = parse_number_value (((TinyOptNumberNode_t *)b->left)->value);
            long c = parse_number_value (
                ((TinyOptNumberNode_t *)b->right)->value);
            long res = eval_binary (b->op, a, c);
            return make_number (res);
          }
        return node;
      }
    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *u = (TinyOptUnaryOpNode_t *)node;
        u->operand = fold_expression (u->operand);
        if (u->op == OP_NOT && is_number_node (u->operand))
          {
            long v = parse_number_value (
                ((TinyOptNumberNode_t *)u->operand)->value);
            return make_number (!v);
          }
        return node;
      }
    case NODE_CONDITION:
      return fold_condition (node);
    default:
      return node;
    }
}
