/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_liveness.h"

int liveness_exp (TinyOptASTNode_t *check, char *name);
int liveness_var_stmt (Symbol *check, char *name);
int liveness_seek_usage (SymbolBucket *check_bucket, char *name);

void
tinyopt_liveness (TinyOptStab_t *table)
{
  if (!table)
    return;

  /* índice do escopo "global" */
  uint64_t global_hash = stab_hash_string ("global");
  size_t global_index = (size_t)(global_hash % table->size);

  for (size_t i = 0; i < table->size; i++)
    {
      SymbolBucket *bucket = table->buckets[i];
      while (bucket)
        {
          Symbol *entry = bucket->symbol;
          if (!entry || !entry->node || !entry->name)
            {
              bucket = bucket->next;
              continue;
            }

          TinyOptASTNode_t *node = entry->node;

          if (node->type == NODE_DECLARATION || node->type == NODE_ASSIGNMENT)
            {
              int used = 0;

              /* Se o escopo deste entry for o "global" */
              int is_global_scope = (i == global_index);

              if (is_global_scope)
                {
                  /* Verifica TODOs os buckets procurando NODE_IDENTIFIER com
                   * mesmo nome */
                  for (size_t j = 0; j < table->size && !used; j++)
                    {
                      SymbolBucket *check_bucket = table->buckets[j];
                      int usage
                          = liveness_seek_usage (check_bucket, entry->name);
                      if (usage)
                        {
                          used = 1;
                          break;
                        }
                    }
                }
              else
                {
                  /* Escopo local: só olhamos no mesmo bucket (index == i) */
                  /* Três casos:
                     A) node == NODE_DECLARATION:  -> percorrer a partir da
                     posição atual (entry) até o fim do bucket
                     B) node == NODE_ASSIGNMENT && entry->loop_hash == 0 ->
                     similar ao A
                     C) node == NODE_ASSIGNMENT &&
                     entry->loop_hash != 0 -> procurar a partir do primeiro
                     elemento com loop_hash igual até fim
                  */

                  if (node->type == NODE_DECLARATION
                      || (node->type == NODE_ASSIGNMENT
                          && entry->loop_hash == 0))
                    {
                      /* percorre a partir da posição atual (entry->bucket
                         node) -> usamos bucket (ponteiro atual) e iniciamos
                         por bucket->next para considerar apenas posições
                         depois do entry. OBS: bucket aponta para o elemento
                         atual do laço externo.
                      */
                      SymbolBucket *tmp = bucket->next;
                      int usage = liveness_seek_usage (tmp, entry->name);
                      if (usage)
                        {
                          used = 1;
                        }
                    }
                  else /* node->type == NODE_ASSIGNMENT && entry->loop_hash !=
                          0 */
                    {
                      /* percorre o bucket inteiro, mas só começa a considerar
                         quando encontrar o primeiro elemento cujo loop_hash ==
                         entry->loop_hash */
                      SymbolBucket *tmp = table->buckets[i];
                      int start_checking = 0;
                      while (tmp)
                        {
                          Symbol *check = tmp->symbol;
                          if (!check)
                            {
                              tmp = tmp->next;
                              continue;
                            }

                          if (!start_checking)
                            {
                              if (check->loop_hash == entry->loop_hash)
                                {
                                  /* a partir daqui passamos a verificar
                                   * (inclusive esse check) */
                                  start_checking = 1;
                                }
                            }

                          if (start_checking)
                            {
                              int stmt
                                  = liveness_var_stmt (check, entry->name);
                              if (stmt)
                                {
                                  used = 1;
                                  break;
                                }
                            }

                          tmp = tmp->next;
                        }
                    }
                }

              if (!used)
                node->is_dead_code = 1;
            }

          bucket = bucket->next;
        }
    }
}

int
liveness_seek_usage (SymbolBucket *check_bucket, char *name)
{
  if (!check_bucket)
    return 0;

  Symbol *check = check_bucket->symbol;
  if (liveness_var_stmt (check, name))
    {
      if (check->node->type == NODE_IDENTIFIER)
        {
          return 1;
        }
      else
        {
          if (check->loop_hash)
            {
              /* Atribuicoes ou declaracoes dentro de loops são verificadas
               * posteriormente, de forma distinta, para evitar loops infinitos
               */
              return 1;
            }
          else
            {
              return liveness_seek_usage (check_bucket->next, check->name);
            }
        }
    }

  return liveness_seek_usage (check_bucket->next, name);
}

int
liveness_exp (TinyOptASTNode_t *check, char *name)
{
  if (!check)
    return 0;

  if (check->type == NODE_IDENTIFIER)
    {
      TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)check;
      return strcmp (id->name, name) == 0;
    }
  else if (check->type == NODE_BINARY_OP)
    {
      TinyOptBinaryOpNode_t *bin = (TinyOptBinaryOpNode_t *)check;
      return liveness_exp (bin->left, name)
             || liveness_exp (bin->right, name) == 1;
    }

  return liveness_exp (check->next, name);
}

int
liveness_var_stmt (Symbol *check, char *name)
{
  if (!check || !check->node || check->node->is_dead_code)
    return 0;

  if (check->node->type == NODE_ASSIGNMENT
      || check->node->type == NODE_DECLARATION)
    {
      TinyOptASTNode_t *value = NULL;
      /* Verifica AST de declaracoes */
      if (check->node->type == NODE_DECLARATION)
        {
          TinyOptDeclarationNode_t *declaration
              = (TinyOptDeclarationNode_t *)check->node;
          if (declaration->initial_value)
            {
              value = (TinyOptASTNode_t *)declaration->initial_value;
            }
        }
      else /* Verifica AST de atribuicoes */
        {
          TinyOptAssignmentNode_t *assig
              = (TinyOptAssignmentNode_t *)check->node;
          if (assig->value)
            {
              value = (TinyOptASTNode_t *)assig->value;
            }
        }
      if (value)
        {
          int exp = liveness_exp (value, name);
          if (exp)
            {
              return 1;
            }
        }
    }

  else if (check->node->type == NODE_IDENTIFIER
           && strcmp (check->name, name) == 0)
    {
      return 1;
    }

  return 0;
}
