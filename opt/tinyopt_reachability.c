/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_reachability.h"

SymbolValue *resolve_final_value (TinyOptStab_t *stab, const char *name,
                                  const char *scope);
int eval_condition (TinyOptASTNode_t *condition, TinyOptStab_t *head,
                    char *scope);
void mark_subtree_dead (TinyOptASTNode_t *node);

void
tinyopt_reachability (TinyOptASTNode_t *node, TinyOptStab_t *head,
                       char *scope)
{
  if (node == NULL)
    return;

  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)node;
        tinyopt_reachability (prog->statements, head, scope);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *if_node = (TinyOptIfNode_t *)node;
        int cond = eval_condition (if_node->condition, head, scope);
        if (cond == 1)
          {
            if (if_node->else_statement)
              {
                mark_subtree_dead (if_node->else_statement);
              }
          }
        else if (cond == 0)
          {
            if (if_node->condition)
              {
                mark_subtree_dead (if_node->condition);
              }
            if (if_node->then_statement)
              {
                mark_subtree_dead (if_node->then_statement);
              }
            if (!if_node->else_statement)
              {
                mark_subtree_dead (node);
              }
          }

        tinyopt_reachability (if_node->condition, head, scope);
        tinyopt_reachability (if_node->then_statement, head, scope);
        tinyopt_reachability (if_node->else_statement, head, scope);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *while_node = (TinyOptWhileNode_t *)node;
        int cond = eval_condition (while_node->condition, head, scope);

        if (cond == 0)
          {
            if (while_node->body)
              {
                mark_subtree_dead (while_node->body);
              }
            node->is_dead_code = 1;
          }

        tinyopt_reachability (while_node->condition, head, scope);
        tinyopt_reachability (while_node->body, head, scope);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *for_node = (TinyOptForNode_t *)node;

        if (for_node->condition)
          {
            int cond = eval_condition (for_node->condition, head, scope);
            if (cond == 0)
              {
                if (for_node->body)
                  {
                    mark_subtree_dead (for_node->body);
                  }
                node->is_dead_code = 1;
              }
          }

        tinyopt_reachability (for_node->init, head, scope);
        tinyopt_reachability (for_node->condition, head, scope);
        tinyopt_reachability (for_node->increment, head, scope);
        tinyopt_reachability (for_node->body, head, scope);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        if (comp->statements)
          {
            tinyopt_reachability (comp->statements, head, scope);
          }
        break;
      }
    case NODE_RETURN:
      {
        if (node->next)
          {
            mark_subtree_dead (node->next);
          }
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        tinyopt_reachability (func->body, head, func->name);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        tinyopt_reachability (call->arguments, head, scope);
        break;
      }
    case NODE_BREAK:
    case NODE_CONTINUE:
      {
        if (node->next)
          {
            mark_subtree_dead (node->next);
          }
        break;
      }
    default:
      break;
    }

  tinyopt_reachability (node->next, head, scope);
}

int
eval_condition (TinyOptASTNode_t *condition, TinyOptStab_t *head, char *scope)
{
  if (!condition)
    return -1;

  SymbolValue *val = evaluate_expression_value (condition, head, scope);

  if (!val)
    return -1; // não foi possível resolver

  if (val->type == VALUE_TYPE_INT)
    {
      if (val->number != 0)
        return 1; // sempre verdadeiro
      else
        return 0; // sempre falso
    }

  return -1; // caso string
}

void
mark_subtree_dead (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;

  node->is_dead_code = 1;

  switch (node->type)
    {
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)node;
        mark_subtree_dead (ifn->condition);
        mark_subtree_dead (ifn->then_statement);
        mark_subtree_dead (ifn->else_statement);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *wn = (TinyOptWhileNode_t *)node;
        mark_subtree_dead (wn->condition);
        mark_subtree_dead (wn->body);
        break;
      }
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *cn = (TinyOptConditionNode_t *)node;
        mark_subtree_dead (cn->left);
        mark_subtree_dead (cn->right);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *fn = (TinyOptForNode_t *)node;
        mark_subtree_dead (fn->init);
        mark_subtree_dead (fn->condition);
        mark_subtree_dead (fn->increment);
        mark_subtree_dead (fn->body);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        TinyOptASTNode_t *stmt = comp->statements;
        while (stmt)
          {
            mark_subtree_dead (stmt);
            stmt = stmt->next;
          }
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        mark_subtree_dead (func->body);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        mark_subtree_dead (call->arguments);
        break;
      }
    default:
      break;
    }

  // mark_subtree_dead(node->next);
}
