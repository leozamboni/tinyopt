/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_reachability.h"

SymbolValue *resolve_final_value (TinyOptStab_t *stab, const char *name,
                                  const char *scope);
SymbolValue *evaluate_expression_value (TinyOptASTNode_t *expr,
                                        TinyOptStab_t *table, char *scope);
int eval_condition (TinyOptASTNode_t *condition, TinyOptStab_t *head,
                    char *scope);
void mark_subtree_dead (TinyOptASTNode_t *node);

void
tinyopt_reachability (TinyOptASTNode_t *node, TinyOptStab_t *head,
                       char *scope)
{
  if (node == NULL)
    return;

  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)node;
        tinyopt_reachability (prog->statements, head, scope);
        break;
      }
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *if_node = (TinyOptIfNode_t *)node;
        int cond = eval_condition (if_node->condition, head, scope);
        if (cond == 1)
          {
            if (if_node->else_statement)
              {
                mark_subtree_dead (if_node->else_statement);
              }
          }
        else if (cond == 0)
          {
            if (if_node->condition)
              {
                mark_subtree_dead (if_node->condition);
              }
            if (if_node->then_statement)
              {
                mark_subtree_dead (if_node->then_statement);
              }
            if (!if_node->else_statement)
              {
                mark_subtree_dead (node);
              }
          }

        tinyopt_reachability (if_node->condition, head, scope);
        tinyopt_reachability (if_node->then_statement, head, scope);
        tinyopt_reachability (if_node->else_statement, head, scope);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *while_node = (TinyOptWhileNode_t *)node;
        int cond = eval_condition (while_node->condition, head, scope);

        if (cond == 0)
          {
            if (while_node->body)
              {
                mark_subtree_dead (while_node->body);
              }
            node->is_dead_code = 1;
          }

        tinyopt_reachability (while_node->condition, head, scope);
        tinyopt_reachability (while_node->body, head, scope);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *for_node = (TinyOptForNode_t *)node;

        if (for_node->condition)
          {
            int cond = eval_condition (for_node->condition, head, scope);
            if (cond == 0)
              {
                if (for_node->body)
                  {
                    mark_subtree_dead (for_node->body);
                  }
                node->is_dead_code = 1;
              }
          }

        tinyopt_reachability (for_node->init, head, scope);
        tinyopt_reachability (for_node->condition, head, scope);
        tinyopt_reachability (for_node->increment, head, scope);
        tinyopt_reachability (for_node->body, head, scope);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        if (comp->statements)
          {
            tinyopt_reachability (comp->statements, head, scope);
          }
        break;
      }
    case NODE_RETURN:
      {
        if (node->next)
          {
            mark_subtree_dead (node->next);
          }
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        tinyopt_reachability (func->body, head, func->name);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        tinyopt_reachability (call->arguments, head, scope);
        break;
      }
    case NODE_BREAK:
    case NODE_CONTINUE:
      {
        if (node->next)
          {
            mark_subtree_dead (node->next);
          }
        break;
      }
    default:
      break;
    }

  tinyopt_reachability (node->next, head, scope);
}

SymbolValue *
resolve_final_value (TinyOptStab_t *stab, const char *name, const char *scope)
{
  if (!stab || !name || !scope)
    return NULL;

  // Hash baseado no escopo
  uint64_t hash = stab_hash_string (scope);
  size_t index = hash % stab->size;

  SymbolBucket *bucket = stab->buckets[index];
  Symbol *last_match = NULL;

  // Percorre o bucket procurando o símbolo mais recente
  while (bucket)
    {
      Symbol *sym = bucket->symbol;
      if (sym && sym->name && strcmp (sym->name, name) == 0
          && !sym->node->is_dead_code)
        {
          last_match = sym;
          // Mantemos o último encontrado (ordem de inserção já garante isso se
          // você usou a versão com append)
        }
      bucket = bucket->next;
    }

  if (!last_match || !last_match->value)
    return NULL;

  SymbolValue *val = last_match->value;

  // Valor literal direto (int ou string)
  if (val->type == VALUE_TYPE_INT || val->type == VALUE_TYPE_STRING)
    return val;

  // Se for uma declaração cujo valor inicial é outro identificador, resolve
  // recursivamente
  if (last_match->node && last_match->node->type == NODE_DECLARATION)
    {
      TinyOptDeclarationNode_t *decl
          = (TinyOptDeclarationNode_t *)last_match->node;
      if (decl->initial_value && decl->initial_value->type == NODE_IDENTIFIER)
        {
          TinyOptIdentifierNode_t *id
              = (TinyOptIdentifierNode_t *)decl->initial_value;
          return resolve_final_value (stab, id->name, scope);
        }
    }

  return NULL;
}

SymbolValue *
evaluate_expression_value (TinyOptASTNode_t *expr, TinyOptStab_t *table,
                           char *scope)
{
  if (!expr)
    return NULL;

  switch (expr->type)
    {
    case NODE_NUMBER:
      {
        TinyOptNumberNode_t *num = (TinyOptNumberNode_t *)expr;
        SymbolValue *val = malloc (sizeof (SymbolValue));
        val->type = VALUE_TYPE_INT;
        val->number = atoi (num->value);
        return val;
      }

    case NODE_STRING_LITERAL:
      {
        TinyOptStringLiteralNode_t *str = (TinyOptStringLiteralNode_t *)expr;
        SymbolValue *val = malloc (sizeof (SymbolValue));
        val->type = VALUE_TYPE_STRING;
        val->str = str->value;
        return val;
      }

    case NODE_IDENTIFIER:
      {
        TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)expr;

        SymbolValue *r = malloc (sizeof (SymbolValue));
        return resolve_final_value (table, id->name, scope);
      }

    case NODE_CONDITION:
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *bin = (TinyOptBinaryOpNode_t *)expr;
        SymbolValue *left_val
            = evaluate_expression_value (bin->left, table, scope);
        SymbolValue *right_val
            = evaluate_expression_value (bin->right, table, scope);

        // CASO: ... || 1
        if (right_val && right_val->type == VALUE_TYPE_INT && bin->op == OP_OR
            && right_val->number > 0)
          {
            return right_val;
          }
        // CASO: 1 || ...
        if (left_val && left_val->type == VALUE_TYPE_INT && bin->op == OP_OR
            && left_val->number > 0)
          {
            return left_val;
          }

        // CASO: ... && 0
        if (right_val && right_val->type == VALUE_TYPE_INT && bin->op == OP_AND
            && right_val->number == 0)
          {
            return right_val;
          }
        // CASO: 0 && ...
        if (left_val && left_val->type == VALUE_TYPE_INT && bin->op == OP_AND
            && left_val->number == 0)
          {
            return left_val;
          }

        if (!left_val || !right_val)
          return NULL;

        // Só tratamos inteiros aqui — strings você pode definir outra
        // semântica depois
        if (left_val->type != VALUE_TYPE_INT
            || right_val->type != VALUE_TYPE_INT)
          return NULL;

        SymbolValue *result = malloc (sizeof (SymbolValue));
        result->type = VALUE_TYPE_INT;

        switch (bin->op)
          {
          case OP_ADD:
            result->number = left_val->number + right_val->number;
            break;
          case OP_SUB:
            result->number = left_val->number - right_val->number;
            break;
          case OP_MUL:
            result->number = left_val->number * right_val->number;
            break;
          case OP_DIV:
            result->number = (right_val->number != 0)
                                 ? left_val->number / right_val->number
                                 : 0;
            break;
            // case '%':
            //     result->number = (right_val->number != 0) ? left_val->number
            //     % right_val->number : 0; break;
          case OP_GT:
            result->number = left_val->number > right_val->number;
            break;
          case OP_LT:
            result->number = left_val->number < right_val->number;
            break;
          case OP_EQ:
            result->number = (left_val->number == right_val->number);
            break;
          case OP_AND:
            result->number = (left_val->number && right_val->number);
            break;
          case OP_OR:
            result->number = (left_val->number || right_val->number);
            break;
          default:
            free (result);
            result = NULL;
            break;
          }

        return result;
      }

    default:
      return NULL;
    }
}

int
eval_condition (TinyOptASTNode_t *condition, TinyOptStab_t *head, char *scope)
{
  if (!condition)
    return -1;

  SymbolValue *val = evaluate_expression_value (condition, head, scope);

  if (!val)
    return -1; // não foi possível resolver

  if (val->type == VALUE_TYPE_INT)
    {
      if (val->number != 0)
        return 1; // sempre verdadeiro
      else
        return 0; // sempre falso
    }

  return -1; // caso string
}

void
mark_subtree_dead (TinyOptASTNode_t *node)
{
  if (node == NULL)
    return;

  node->is_dead_code = 1;

  switch (node->type)
    {
    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *ifn = (TinyOptIfNode_t *)node;
        mark_subtree_dead (ifn->condition);
        mark_subtree_dead (ifn->then_statement);
        mark_subtree_dead (ifn->else_statement);
        break;
      }
    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *wn = (TinyOptWhileNode_t *)node;
        mark_subtree_dead (wn->condition);
        mark_subtree_dead (wn->body);
        break;
      }
    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *cn = (TinyOptConditionNode_t *)node;
        mark_subtree_dead (cn->left);
        mark_subtree_dead (cn->right);
        break;
      }
    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *fn = (TinyOptForNode_t *)node;
        mark_subtree_dead (fn->init);
        mark_subtree_dead (fn->condition);
        mark_subtree_dead (fn->increment);
        mark_subtree_dead (fn->body);
        break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        TinyOptASTNode_t *stmt = comp->statements;
        while (stmt)
          {
            mark_subtree_dead (stmt);
            stmt = stmt->next;
          }
        break;
      }
    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        mark_subtree_dead (func->body);
        break;
      }
    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        mark_subtree_dead (call->arguments);
        break;
      }
    default:
      break;
    }

  // mark_subtree_dead(node->next);
}
