/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni 
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include <stdio.h>
#include "tinyopt_code.h"

static void emit_stmt_list (TinyOptASTNode_t * node);
static void emit_stmt (TinyOptASTNode_t * node);
static void emit_expr (TinyOptASTNode_t * node);
static const char *dtype_to_str (DataType t);
static const char *op_to_assign_str (Operator op);
static const char *relop_to_str (Operator op);
static void emit_indent (int n);
static void emit_block (TinyOptASTNode_t * node, int indent);
static void emit_parameter_list (TinyOptASTNode_t * node);
static void emit_argument_list (TinyOptASTNode_t * node);

void
print_optimized_code (TinyOptASTNode_t *ast)
{
  if (!ast)
    {
      printf ("\n");
      return;
    }
  if (ast->type == NODE_PROGRAM)
    {
      TinyOptProgramNode_t *p = (TinyOptProgramNode_t *) ast;
      emit_stmt_list (p->statements);
    }
  else
    {
      emit_stmt (ast);
    }
}

static void
emit_stmt_list (TinyOptASTNode_t *node)
{
  for (TinyOptASTNode_t * cur = node; cur; cur = cur->next)
    {
      emit_stmt (cur);
    }
}

static const char *
dtype_to_str (DataType t)
{
  switch (t)
    {
    case TYPE_INT:
      return "int";
    case TYPE_FLOAT:
      return "float";
    case TYPE_CHAR:
      return "char";
    case TYPE_VOID:
      return "void";
    case TYPE_ARRAY:
      return "int";
    default:
      return "int";
    }
}

static const char *
op_to_assign_str (Operator op)
{
  switch (op)
    {
    case OP_ASSIGN:
      return "=";
    case OP_ADD_ASSIGN:
      return "+=";
    case OP_SUB_ASSIGN:
      return "-=";
    case OP_MUL_ASSIGN:
      return "*=";
    case OP_DIV_ASSIGN:
      return "/=";
    case OP_MOD_ASSIGN:
      return "%=";
    default:
      return NULL;
    }
}

static const char *
relop_to_str (Operator op)
{
  switch (op)
    {
    case OP_EQ:
      return "==";
    case OP_NE:
      return "!=";
    case OP_LT:
      return "<";
    case OP_LE:
      return "<=";
    case OP_GT:
      return ">";
    case OP_GE:
      return ">=";
    case OP_OR:
      return "||";
    default:
      return "?";
    }
}

static void
emit_indent (int n)
{
  for (int i = 0; i < n; i++)
    printf ("  ");
}

static void
emit_block (TinyOptASTNode_t *node, int indent)
{
  printf ("{\n");
  for (TinyOptASTNode_t * cur = node; cur; cur = cur->next)
    {
      emit_indent (indent);
      emit_stmt (cur);
    }
  emit_indent (indent - 1);
  printf ("}\n");
}

static void
emit_stmt (TinyOptASTNode_t *node)
{
  if (!node)
    return;
  switch (node->type)
    {
    case NODE_DECLARATION:
      {
	TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *) node;
	printf ("%s %s", dtype_to_str (d->data_type), d->name);
	if (d->array_size > 0)
	  printf ("[%d]", d->array_size);
	if (d->initial_value)
	  {
	    printf (" = ");
	    emit_expr (d->initial_value);
	  }
	printf (";\n");
	break;
      }
    case NODE_ASSIGNMENT:
      {
	TinyOptAssignmentNode_t *a = (TinyOptAssignmentNode_t *) node;
	const char *as = op_to_assign_str (a->op);
	if (as)
	  {
	    printf ("%s %s ", a->variable, as);
	    if (a->value)
	      emit_expr (a->value);
	    printf (";\n");
	  }
	else if (a->op == OP_INC)
	  {
	    printf ("%s++;\n", a->variable);
	  }
	else if (a->op == OP_DEC)
	  {
	    printf ("%s--;\n", a->variable);
	  }
	else
	  {
	    printf ("/* unsupported assignment op */\n");
	  }
	break;
      }
    case NODE_IF_STATEMENT:
      {
	TinyOptIfNode_t *i = (TinyOptIfNode_t *) node;

	if (!i->condition && i->then_statement && !i->else_statement)
	  {
	    if (i->then_statement->type == NODE_COMPOUND_STATEMENT)
	      { 
		emit_stmt_list (((TinyOptCompoundNode_t *) i->then_statement)->
				statements);
	      }
	    else
	      {
		emit_stmt (i->then_statement);
	      }
	    break;
	  }
	if (!i->condition && !i->then_statement && i->else_statement)
	  {
	    if (i->else_statement->type == NODE_COMPOUND_STATEMENT)
	      {
		emit_stmt_list (((TinyOptCompoundNode_t *) i->else_statement)->
				statements);
	      }
	    else
	      {
		emit_stmt (i->else_statement);
	      }
	    break;
	  }

	if (i->then_statement
	    && i->then_statement->type == NODE_COMPOUND_STATEMENT)
	  {
	    printf ("if (");
	    emit_expr (i->condition);
	    printf (") ");
	    emit_block (((TinyOptCompoundNode_t *) i->then_statement)->statements, 1);
	  }
	if (i->else_statement)
	  {
	    if (i->then_statement)
	      {
		printf ("else ");
	      }
	    if (i->else_statement->type == NODE_COMPOUND_STATEMENT)
	      {
		emit_block (((TinyOptCompoundNode_t *) i->else_statement)->statements,
			    1);
	      }
	    else
	      {
		printf ("{\n  ");
		emit_stmt (i->else_statement);
		printf ("}\n");
	      }
	  }
	break;
      }
    case NODE_WHILE_STATEMENT:
      {
	TinyOptWhileNode_t *w = (TinyOptWhileNode_t *) node;
	printf ("while (");
	emit_expr (w->condition);
	printf (") ");
	if (w->body && w->body->type == NODE_COMPOUND_STATEMENT)
	  {
	    emit_block (((TinyOptCompoundNode_t *) w->body)->statements, 1);
	  }
	else
	  {
	    printf ("{\n  ");
	    emit_stmt (w->body);
	    printf ("}\n");
	  }
	break;
      }
    case NODE_FOR_STATEMENT:
      {
	TinyOptForNode_t *f = (TinyOptForNode_t *) node;
	printf ("for (");
	if (f->init && f->init->type == NODE_ASSIGNMENT)
	  {
	    TinyOptAssignmentNode_t *a = (TinyOptAssignmentNode_t *) f->init;
	    printf ("%s %s ", a->variable, op_to_assign_str (a->op));
	    if (a->value)
	      emit_expr (a->value);
	  }
	else if (f->init && f->init->type == NODE_DECLARATION)
	  {
	    TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *) f->init;
	    printf ("%s %s", dtype_to_str (d->data_type), d->name);
	    if (d->initial_value)
	      {
		printf (" = ");
		emit_expr (d->initial_value);
	      }
	  }
	printf ("; ");
	if (f->condition)
	  emit_expr (f->condition);
	printf ("; ");
	if (f->increment && f->increment->type == NODE_ASSIGNMENT)
	  {
	    TinyOptAssignmentNode_t *a = (TinyOptAssignmentNode_t *) f->increment;
	    const char *as = op_to_assign_str (a->op);
	    if (as)
	      {
		printf ("%s %s ", a->variable, as);
		if (a->value)
		  emit_expr (a->value);
	      }
	    else if (a->op == OP_INC)
	      {
		printf ("%s++", a->variable);
	      }
	    else if (a->op == OP_DEC)
	      {
		printf ("%s--", a->variable);
	      }
	  }
	printf (") ");
	if (f->body && f->body->type == NODE_COMPOUND_STATEMENT)
	  {
	    emit_block (((TinyOptCompoundNode_t *) f->body)->statements, 1);
	  }
	else
	  {
	    printf ("{\n  ");
	    emit_stmt (f->body);
	    printf ("}\n");
	  }
	break;
      }
    case NODE_COMPOUND_STATEMENT:
      {
	TinyOptCompoundNode_t *c = (TinyOptCompoundNode_t *) node;
	emit_block (c->statements, 1);
	break;
      }
    case NODE_RETURN:
      {
	TinyOptReturnNode_t *r = (TinyOptReturnNode_t *) node;
	printf ("return ");
	emit_expr (r->value);
	printf (";\n");
	break;
      }
    case NODE_BREAK:
      {
	printf ("break;\n");
	break;
      }
    case NODE_CONTINUE:
      {
	printf ("continue;\n");
	break;
      }
    case NODE_FUNCTION_DEF:
      {
	TinyOptFunctionDefNode_t *f = (TinyOptFunctionDefNode_t *) node;
	printf ("%s %s(", dtype_to_str (f->return_type), f->name);
	if (f->parameters)
	  {
	    emit_parameter_list (f->parameters);
	  }
	printf (") ");
	if (f->body && f->body->type == NODE_COMPOUND_STATEMENT)
	  {
	    emit_block (((TinyOptCompoundNode_t *) f->body)->statements, 0);
	  }
	else
	  {
	    printf ("{\n  ");
	    emit_stmt (f->body);
	    printf ("}\n");
	  }
	break;
      }
    default:
      break;
    }
}

static void
emit_parameter_list (TinyOptASTNode_t *node)
{
  if (!node)
    return;
  // Parâmetros são armazenados como uma lista de declarações
  TinyOptASTNode_t *cur = node;
  int first = 1;
  while (cur && cur->type == NODE_DECLARATION)
    {
      if (!first)
	printf (", ");
      first = 0;
      TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *) cur;
      printf ("%s %s", dtype_to_str (d->data_type), d->name);
      cur = cur->next;
    }
  // Se for um ProgramNode, iterar sobre statements
  if (node->type == NODE_PROGRAM)
    {
      TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *) node;
      cur = prog->statements;
      while (cur)
	{
	  if (!first)
	    printf (", ");
	  first = 0;
	  if (cur->type == NODE_DECLARATION)
	    {
	      TinyOptDeclarationNode_t *d = (TinyOptDeclarationNode_t *) cur;
	      printf ("%s %s", dtype_to_str (d->data_type), d->name);
	    }
	  cur = cur->next;
	}
    }
}

static void
emit_argument_list (TinyOptASTNode_t *node)
{
  if (!node)
    return;
  // Argumentos são armazenados como uma lista de expressões
  TinyOptASTNode_t *cur = node;
  int first = 1;
  // Se for um ProgramNode, iterar sobre statements
  if (node->type == NODE_PROGRAM)
    {
      TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *) node;
      cur = prog->statements;
      while (cur)
	{
	  if (!first)
	    printf (", ");
	  first = 0;
	  emit_expr (cur);
	  cur = cur->next;
	}
    }
  else
    {
      // Tentar iterar diretamente
      while (cur)
	{
	  if (!first)
	    printf (", ");
	  first = 0;
	  emit_expr (cur);
	  cur = cur->next;
	}
    }
}

static void
emit_expr (TinyOptASTNode_t *node)
{
  if (!node)
    {
      printf ("");
      return;
    }
  switch (node->type)
    {
    case NODE_NUMBER:
      printf ("%s", ((TinyOptNumberNode_t *) node)->value);
      break;
    case NODE_IDENTIFIER:
      printf ("%s", ((TinyOptIdentifierNode_t *) node)->name);
      break;
    case NODE_BINARY_OP:
      {
	TinyOptBinaryOpNode_t *b = (TinyOptBinaryOpNode_t *) node;
	printf ("(");
	emit_expr (b->left);
	const char *op = "?";
	switch (b->op)
	  {
	  case OP_ADD:
	    op = "+";
	    break;
	  case OP_SUB:
	    op = "-";
	    break;
	  case OP_MUL:
	    op = "*";
	    break;
	  case OP_DIV:
	    op = "/";
	    break;
	  case OP_MOD:
	    op = "%";
	    break;
	  default:
	    break;
	  }
	printf (" %s ", op);
	emit_expr (b->right);
	printf (")");
	break;
      }
    case NODE_CONDITION:
      {
	TinyOptConditionNode_t *c = (TinyOptConditionNode_t *) node;
	printf ("(");
	emit_expr (c->left);
	printf (" %s ", relop_to_str (c->op));
	emit_expr (c->right);
	printf (")");
	break;
      }
    case NODE_UNARY_OP:
      {
	TinyOptUnaryOpNode_t *u = (TinyOptUnaryOpNode_t *) node;
	if (u->op == OP_NOT)
	  {
	    printf ("!");
	    emit_expr (u->operand);
	  }
	else
	  {
	    emit_expr (u->operand);
	  }
	break;
      }
    case NODE_FUNCTION_CALL:
      {
	TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *) node;
	printf ("%s(", call->name);
	if (call->arguments)
	  {
	    emit_argument_list (call->arguments);
	  }
	printf (")");
	break;
      }
    default:
      printf ("0");
      break;
    }
}
