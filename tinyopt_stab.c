/*⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢫⣶⢾⣰⣿⣑⣶⣕⡫⢙⣭⣖⣷⣶⣹⣿⣻⣟⠉⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣮⡟⣼⣶⣶⠶⠶⠶⢶⣶⢶⠶⠶⠶⢶⣶⣶⡶⢰⢿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⡼⠱⣫⣶⣾⠟⠿⣿⠨⣆⣿⢰⣿⠿⣿⢶⣬⠃⣷⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢿⣾⢿⣷⣌⣀⣈⣿⠘⣧⢸⢸⡿⡟⢁⣋⡩⣷⣬⣾⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⠹⣑⡲⣶⣦⡻⠿⣿⢠⣍⢴⢸⣿⣰⣿⡿⢃⣜⢗⣸⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⢸⢿⡿⠋⠙⣿⠹⣿⢸⠏⠾⢸⣯⢣⣾⣟⣻⣭⡛⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣤⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⣿⣞⢾⣧⣻⣾⣋⣾⣾⠀⠸⢓⢸⡟⣆⢿⢼⣗⠉⡽⣸⡇⠀⠀⣠⡦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠂⠁⠀⠉⠙⢿⣷⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠀
 *⠀⣿⢛⣥⣬⣛⡿⣦⢫⣿⢸⣇⣿⢸⡿⣳⣥⣜⣿⢿⡾⢿⡇⠀⠀⢈⡀⠀⠀⢀⡀⠀⢀⣀⠀⠀⠀⣀⡀⠀⠀⠀⢀⡀⠀⠀⣴⠃⠀⠀⠀⠀⠀⠀⢻⣿⠀⠀⣀⡀⠀⢀⣀⠀⠀⢀⣾⣇⣀⡀
 *⠀⣿⣿⢋⣽⣶⣯⡈⢼⣿⠸⣦⢸⢸⡟⠿⢍⣿⣝⠸⣸⢿⡇⠀⠐⢿⡇⠀⠐⢿⡧⠐⠙⢻⣷⠀⠈⢻⣿⠀⠀⠀⢻⣷⠀⢸⣿⠀⠀⠀⠀⠀⠀⠀⠈⣿⠂⠘⣿⡧⠊⠙⢿⣷⠀⠉⣿⡏⠉⠀
 *⠀⣿⡗⣼⣟⣉⢻⡹⢸⣿⢸⡌⣸⠘⡿⠿⣿⣟⣻⡇⣱⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⠀⠀⠀⢸⣿⠀⢸⣿⡀⠀⠀⠀⠀⠀⠀⢀⡿⠀⠀⣿⡇⠀⠀⠈⣿⠀⠀⣿⡇⠀⠀
 *⠀⣿⣷⢩⣿⣵⡿⣣⡾⣣⣟⣁⣙⣧⡻⢇⡽⢟⣉⠪⢭⣿⡇⠀⠀⢸⡇⠀⠀⢸⡇⠀⠀⢸⣿⠀⠀⢸⣿⡀⠀⠀⣸⡇⠀⠈⢿⣷⣄⠀⠀⠀⠀⢀⡼⠁⠀⠀⣿⡇⠀⠀⢀⠟⠀⠀⣿⡇⠀⠀
 *⠀⠿⠶⠾⠿⠶⠿⠿⠶⠶⠶⠶⠶⠶⠶⠾⠿⠿⠿⠿⠾⠿⠇⠀⠀⠸⠿⠂⠀⠸⠿⠂⠀⠘⠿⠓⠀⠈⠻⡿⠒⠁⢸⣷⠀⠀⠀⠙⠻⠿⠶⠶⠖⠉⠀⠀⠀⠀⣿⡿⠿⠖⠀⠀⠀⠀⠻⠿⠖⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡎⠀⠀⠀⢸⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠻⠿⠶⠂⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
 *  TinyOpt
 *  Copyright (c) 2025 leozamboni
 *
 *  this program is free software: you can redistribute it and/or modify
 *  it under the terms of the gnu general public license as published by
 *  the free software foundation, either version 3 of the license, or
 *  (at your option) any later version.
 *
 *  this program is distributed in the hope that it will be useful,
 *  but without any warranty; without even the implied warranty of
 *  merchantability or fitness for a particular purpose.  see the
 *  gnu general public license for more details.
 *
 *  you should have received a copy of the gnu general public license
 *  along with this program.  if not, see <http://www.gnu.org/licenses/>.
 */
#include "tinyopt_stab.h"

void
tinyopt_stab_init (TinyOptASTNode_t *node, TinyOptStab_t *stab,
                   uint64_t loop_hash, const char *scope)
{
  if (!node || !stab)
    return;

  switch (node->type)
    {
    case NODE_PROGRAM:
      {
        TinyOptProgramNode_t *prog = (TinyOptProgramNode_t *)node;
        tinyopt_stab_init (prog->statements, stab, loop_hash, scope);
        break;
      }

    case NODE_DECLARATION:
      {
        TinyOptDeclarationNode_t *decl = (TinyOptDeclarationNode_t *)node;
        if (decl->name)
          {
            Symbol *sym = malloc (sizeof (Symbol));
            if (!sym)
              break;

            sym->node = node;
            sym->name = decl->name;
            sym->id_hash = decl->hash;
            sym->loop_hash = loop_hash;
            sym->value = NULL;

            if (decl->initial_value
                && decl->initial_value->type == NODE_FUNCTION_CALL)
              {
                TinyOptFunctionCallNode_t *fcall
                    = (TinyOptFunctionCallNode_t *)decl->initial_value;
                if (fcall->arguments)
                  {
                    tinyopt_stab_init (fcall->arguments, stab, loop_hash,
                                       scope);
                  }
              }

            if (decl->initial_value)
              {
                SymbolValue *val = evaluate_expression_value (
                    decl->initial_value, stab, scope);
                if (val)
                  {
                    sym->value = malloc (sizeof (SymbolValue));
                    memcpy (sym->value, val, sizeof (SymbolValue));
                  }
              }

            stab_insert (stab, sym, scope);
          }

        // tinyopt_stab_init (decl->initial_value, stab, loop_hash, scope);
        break;
      }

    case NODE_ASSIGNMENT:
      {
        TinyOptAssignmentNode_t *assign = (TinyOptAssignmentNode_t *)node;
        if (assign->variable)
          {
            Symbol *sym = malloc (sizeof (Symbol));
            if (!sym)
              break;

            sym->node = node;
            sym->name = assign->variable;
            sym->id_hash = assign->hash;
            sym->loop_hash = loop_hash;
            sym->value = NULL;

            if (assign->value && assign->value->type == NODE_FUNCTION_CALL)
              {
                TinyOptFunctionCallNode_t *fcall
                    = (TinyOptFunctionCallNode_t *)assign->value;
                if (fcall->arguments)
                  {
                    tinyopt_stab_init (fcall->arguments, stab, loop_hash,
                                       scope);
                  }
              }

            if (assign->value)
              {
                SymbolValue *val
                    = evaluate_expression_value (assign->value, stab, scope);
                if (val)
                  {
                    sym->value = malloc (sizeof (SymbolValue));
                    memcpy (sym->value, val, sizeof (SymbolValue));
                  }
              }

            stab_insert (stab, sym, scope);
          }
        // tinyopt_stab_init (assign->value, stab, loop_hash, scope);
        break;
      }

    case NODE_IDENTIFIER:
      {
        TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)node;
        if (id->name)
          {
            SymbolValue *val = resolve_final_value (stab, id->name, scope);

            Symbol *sym = malloc (sizeof (Symbol));
            if (!sym)
              break;

            sym->node = node;
            sym->name = id->name;
            sym->id_hash = id->hash;
            sym->loop_hash = loop_hash;
            sym->value = NULL;

            if (val)
              {
                sym->value = malloc (sizeof (SymbolValue));
                memcpy (sym->value, val, sizeof (SymbolValue));
              }

            stab_insert (stab, sym, scope);
          }
        break;
      }

    case NODE_EXPRESSION:
      {
        TinyOptExpressionNode_t *expr = (TinyOptExpressionNode_t *)node;
        tinyopt_stab_init (expr->left, stab, loop_hash, scope);
        tinyopt_stab_init (expr->right, stab, loop_hash, scope);
        break;
      }

    case NODE_CONDITION:
      {
        TinyOptConditionNode_t *cond = (TinyOptConditionNode_t *)node;
        tinyopt_stab_init (cond->left, stab, loop_hash, scope);
        tinyopt_stab_init (cond->right, stab, loop_hash, scope);
        break;
      }

    case NODE_IF_STATEMENT:
      {
        TinyOptIfNode_t *if_node = (TinyOptIfNode_t *)node;
        tinyopt_stab_init (if_node->condition, stab, loop_hash, scope);
        tinyopt_stab_init (if_node->then_statement, stab, loop_hash, scope);
        tinyopt_stab_init (if_node->else_statement, stab, loop_hash, scope);
        break;
      }

    case NODE_WHILE_STATEMENT:
      {
        TinyOptWhileNode_t *while_node = (TinyOptWhileNode_t *)node;
        tinyopt_stab_init (while_node->condition, stab, while_node->loop_hash,
                           scope);
        tinyopt_stab_init (while_node->body, stab, while_node->loop_hash,
                           scope);
        break;
      }

    case NODE_FOR_STATEMENT:
      {
        TinyOptForNode_t *for_node = (TinyOptForNode_t *)node;
        tinyopt_stab_init (for_node->init, stab, for_node->loop_hash, scope);
        tinyopt_stab_init (for_node->condition, stab, for_node->loop_hash,
                           scope);
        tinyopt_stab_init (for_node->increment, stab, for_node->loop_hash,
                           scope);
        tinyopt_stab_init (for_node->body, stab, for_node->loop_hash, scope);
        break;
      }

    case NODE_COMPOUND_STATEMENT:
      {
        TinyOptCompoundNode_t *comp = (TinyOptCompoundNode_t *)node;
        if (comp->statements)
          tinyopt_stab_init (comp->statements, stab, loop_hash, scope);
        break;
      }

    case NODE_RETURN:
      {
        TinyOptReturnNode_t *ret = (TinyOptReturnNode_t *)node;
        tinyopt_stab_init (ret->value, stab, loop_hash, scope);
        break;
      }

    case NODE_FUNCTION_DEF:
      {
        TinyOptFunctionDefNode_t *func = (TinyOptFunctionDefNode_t *)node;
        tinyopt_stab_init (func->parameters, stab, loop_hash, func->name);
        tinyopt_stab_init (func->body, stab, loop_hash, func->name);
        break;
      }

    case NODE_FUNCTION_CALL:
      {
        TinyOptFunctionCallNode_t *call = (TinyOptFunctionCallNode_t *)node;
        tinyopt_stab_init (call->arguments, stab, loop_hash, scope);
        break;
      }

    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *bin = (TinyOptBinaryOpNode_t *)node;
        tinyopt_stab_init (bin->left, stab, loop_hash, scope);
        tinyopt_stab_init (bin->right, stab, loop_hash, scope);
        break;
      }

    case NODE_UNARY_OP:
      {
        TinyOptUnaryOpNode_t *unary = (TinyOptUnaryOpNode_t *)node;
        tinyopt_stab_init (unary->operand, stab, loop_hash, scope);
        break;
      }

    default:
      break;
    }

  // percorre o próximo nó
  tinyopt_stab_init (node->next, stab, loop_hash, scope);
}

SymbolValue *
evaluate_expression_value (TinyOptASTNode_t *expr, TinyOptStab_t *table,
                           char *scope)
{
  if (!expr)
    return NULL;

  switch (expr->type)
    {
    case NODE_NUMBER:
      {
        TinyOptNumberNode_t *num = (TinyOptNumberNode_t *)expr;
        SymbolValue *val = malloc (sizeof (SymbolValue));
        val->type = VALUE_TYPE_INT;
        val->number = atoi (num->value);
        return val;
      }

    case NODE_STRING_LITERAL:
      {
        TinyOptStringLiteralNode_t *str = (TinyOptStringLiteralNode_t *)expr;
        SymbolValue *val = malloc (sizeof (SymbolValue));
        val->type = VALUE_TYPE_STRING;
        val->str = str->value;
        return val;
      }

    case NODE_IDENTIFIER:
      {
        TinyOptIdentifierNode_t *id = (TinyOptIdentifierNode_t *)expr;

        SymbolValue *r = malloc (sizeof (SymbolValue));
        return resolve_final_value (table, id->name, scope);
      }

    case NODE_CONDITION:
    case NODE_BINARY_OP:
      {
        TinyOptBinaryOpNode_t *bin = (TinyOptBinaryOpNode_t *)expr;
        SymbolValue *left_val
            = evaluate_expression_value (bin->left, table, scope);
        SymbolValue *right_val
            = evaluate_expression_value (bin->right, table, scope);

        // CASO: ... || 1
        if (right_val && right_val->type == VALUE_TYPE_INT && bin->op == OP_OR
            && right_val->number > 0)
          {
            return right_val;
          }
        // CASO: 1 || ...
        if (left_val && left_val->type == VALUE_TYPE_INT && bin->op == OP_OR
            && left_val->number > 0)
          {
            return left_val;
          }

        // CASO: ... && 0
        if (right_val && right_val->type == VALUE_TYPE_INT && bin->op == OP_AND
            && right_val->number == 0)
          {
            return right_val;
          }
        // CASO: 0 && ...
        if (left_val && left_val->type == VALUE_TYPE_INT && bin->op == OP_AND
            && left_val->number == 0)
          {
            return left_val;
          }

        if (!left_val || !right_val)
          return NULL;

        // Só tratamos inteiros aqui — strings você pode definir outra
        // semântica depois
        if (left_val->type != VALUE_TYPE_INT
            || right_val->type != VALUE_TYPE_INT)
          return NULL;

        SymbolValue *result = malloc (sizeof (SymbolValue));
        result->type = VALUE_TYPE_INT;

        switch (bin->op)
          {
          case OP_ADD:
            result->number = left_val->number + right_val->number;
            break;
          case OP_SUB:
            result->number = left_val->number - right_val->number;
            break;
          case OP_MUL:
            result->number = left_val->number * right_val->number;
            break;
          case OP_DIV:
            result->number = (right_val->number != 0)
                                 ? left_val->number / right_val->number
                                 : 0;
            break;
            // case '%':
            //     result->number = (right_val->number != 0) ? left_val->number
            //     % right_val->number : 0; break;
          case OP_GT:
            result->number = left_val->number > right_val->number;
            break;
          case OP_LT:
            result->number = left_val->number < right_val->number;
            break;
          case OP_EQ:
            result->number = (left_val->number == right_val->number);
            break;
          case OP_AND:
            result->number = (left_val->number && right_val->number);
            break;
          case OP_OR:
            result->number = (left_val->number || right_val->number);
            break;
          default:
            free (result);
            result = NULL;
            break;
          }

        return result;
      }

    default:
      return NULL;
    }
}

SymbolValue *
resolve_final_value (TinyOptStab_t *stab, const char *name, const char *scope)
{
  if (!stab || !name || !scope)
    return NULL;

  // Hash baseado no escopo
  uint64_t hash = stab_hash_string (scope);
  size_t index = hash % stab->size;

  SymbolBucket *bucket = stab->buckets[index];
  Symbol *last_match = NULL;

  // Percorre o bucket procurando o símbolo mais recente
  while (bucket)
    {
      Symbol *sym = bucket->symbol;
      if (sym && sym->name && strcmp (sym->name, name) == 0
          && !sym->node->is_dead_code)
        {
          last_match = sym;
          // Mantemos o último encontrado (ordem de inserção já garante isso se
          // você usou a versão com append)
        }
      bucket = bucket->next;
    }

  if (!last_match || !last_match->value)
    return NULL;

  SymbolValue *val = last_match->value;

  // Valor literal direto (int ou string)
  if (val->type == VALUE_TYPE_INT || val->type == VALUE_TYPE_STRING)
    return val;

  // Se for uma declaração cujo valor inicial é outro identificador, resolve
  // recursivamente
  if (last_match->node && last_match->node->type == NODE_DECLARATION)
    {
      TinyOptDeclarationNode_t *decl
          = (TinyOptDeclarationNode_t *)last_match->node;
      if (decl->initial_value && decl->initial_value->type == NODE_IDENTIFIER)
        {
          TinyOptIdentifierNode_t *id
              = (TinyOptIdentifierNode_t *)decl->initial_value;
          return resolve_final_value (stab, id->name, scope);
        }
    }

  return NULL;
}

uint64_t
stab_hash_string (const char *str)
{
  uint64_t hash = 5381;
  int c;
  while ((c = *str++))
    hash = ((hash << 5) + hash) + c;
  return hash;
}

TinyOptStab_t *
stab_create (size_t size)
{
  TinyOptStab_t *table = malloc (sizeof (TinyOptStab_t));
  if (!table)
    return NULL;
  table->size = size;
  table->buckets = calloc (size, sizeof (SymbolBucket *));
  if (!table->buckets)
    {
      free (table);
      return NULL;
    }
  return table;
}

void
stab_insert (TinyOptStab_t *table, Symbol *symbol, const char *scope)
{
  if (!table || !symbol || !scope)
    return;

  SymbolBucket *new = malloc (sizeof (SymbolBucket));
  if (!new)
    return;

  uint64_t hash = stab_hash_string (scope);
  size_t index = hash % table->size;

  new->symbol = symbol;
  new->next = NULL;

  if (table->buckets[index] == NULL)
    {
      table->buckets[index] = new;
    }
  else
    {
      SymbolBucket *curr = table->buckets[index];
      while (curr->next)
        curr = curr->next;
      curr->next = new;
    }

  return;
}

Symbol *
stab_get (TinyOptStab_t *table, const char *scope, const char *name)
{
  if (!table || !scope || !name)
    return NULL;

  uint64_t hash = stab_hash_string (scope);
  size_t index = hash % table->size;

  SymbolBucket *bucket = table->buckets[index];
  while (bucket)
    {
      if (strcmp (bucket->symbol->name, name) == 0)
        return bucket->symbol;
      bucket = bucket->next;
    }
  return NULL;
}

void
free_stab (TinyOptStab_t *table)
{
  if (!table)
    return;

  for (size_t i = 0; i < table->size; i++)
    {
      SymbolBucket *bucket = table->buckets[i];
      while (bucket)
        {
          SymbolBucket *next_bucket = bucket->next;
          Symbol *symbol = bucket->symbol;

          if (symbol)
            {
              if (symbol->value)
                {
                  if (symbol->value->type == VALUE_TYPE_STRING
                      && symbol->value->str)
                    {
                      free (symbol->value->str);
                      symbol->value->str = NULL;
                    }
                  free (symbol->value);
                  symbol->value = NULL;
                }

              free (symbol);
            }

          free (bucket);
          bucket = next_bucket;
        }
    }

  free (table->buckets);
  free (table);
}
